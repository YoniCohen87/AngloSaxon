<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Watermark Studio — Smooth Drag + Robust Template I/O</title>
  <style>
    :root{
      --bg:#0b0d12; --panel:#131722; --muted:#8b9bb3; --text:#e6edf6;
      --accent:#7aa2f7; --border:#273042; --headH:66px;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    *{ box-sizing:border-box; }
    html,body{ margin:0; }
    html { overflow-x:hidden; }
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: linear-gradient(180deg,#0b0d12 0%,#101521 100%);
      color:var(--text);
      min-height:100svh;
      overflow-y:auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-gutter: stable both-edges;
    }
    @supports not (min-height:100svh){ body{ min-height:100vh; } }

    header{
      padding: calc(12px + var(--safe-top)) 16px 12px;
      border-bottom:1px solid var(--border);
      background:rgba(19,23,34,0.8);
      position:sticky; top:0; backdrop-filter: blur(6px);
      display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:start;
      z-index:10; min-width:0; max-width:100%;
    }
    header h1{ font-size:18px; margin:0; font-weight:700; letter-spacing:.2px; }
    header .sub{ color:var(--muted); font-size:12px; margin-top:2px; }
    .head-left{ display:flex; flex-direction:column; gap:2px; min-width:0; }

    details.actions-card{
      border:1px solid var(--border); border-radius:12px;
      background:rgba(19,23,34,0.5);
      min-width: 260px;
    }
    details.actions-card > summary{
      list-style:none; cursor:pointer; font-weight:700;
      padding:8px 10px; font-size:.9rem; color:#c9d5ea;
    }
    details.actions-card[open] > summary{ border-bottom:1px solid var(--border); }
    .head-actions{ padding:8px; display:flex; gap:6px; align-items:center; overflow-x:auto; -webkit-overflow-scrolling:touch; }
    .btn{
      background:#1a2440; color:#fff; border:1px solid var(--border);
      padding:8.5px 10px; border-radius:10px; cursor:pointer; transition:.15s ease;
      font-weight:600; white-space:nowrap; flex:0 0 auto; min-height:38px; font-size:.85rem;
    }
    .btn.primary{ background:#183055; border-color:#2b4e86; }
    .btn.accent{ background:var(--accent); color:#0b0d12; border:none; }
    .btn.warn{ background:#5b2330; border-color:#7b2d3f; }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn:hover:not(:disabled){ filter:brightness(1.05); transform:translateY(-1px); }
    .btn:active{ transform:translateY(0); }
    .note{ color:var(--muted); font-size:12px; margin-left:4px; white-space:nowrap; }

    .mobile-tabs{
      display:none; grid-column:1 / -1; margin-top:6px; gap:8px; max-width:100%;
    }
    .tab{
      flex:1 1 0; text-align:center; border-radius:999px; padding:8px 12px; font-weight:700;
      border:1px solid var(--border); background:#0f1421; cursor:pointer; min-height:40px;
    }
    .tab.active{ background:#1a2440; border-color:#2b4e86; }

    .wrap{
      display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:12px;
      width:100%; max-width:100%;
    }

    .col{ display:flex; flex-direction:column; min-width:0; }
    .controls-scroll{ padding-right: 6px; }

    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; overflow:hidden; margin-bottom:12px; max-width:100%; }
    .card summary, .card h2{
      font-size:14px; letter-spacing:.3px; margin:0; padding:12px 14px;
      border-bottom:1px solid var(--border); color:#c9d5ea; list-style:none;
    }
    details.card > summary{ cursor:pointer; }
    details.card[open] > summary{ border-bottom:1px solid var(--border); }
    .card .body{ padding:12px; display:flex; flex-direction:column; gap:12px; }

    /* Preview: fixed height; native pan when zoomed */
    .preview{
      position:relative;
      background:#0a0f1c; border:1px solid var(--border); border-radius:14px;
      height: 60vh;
      min-height: 320px;
      padding:8px;
      contain: layout paint; isolation:isolate;
      touch-action: pan-x pan-y;
      overscroll-behavior: contain;
      max-width:100%;
      overflow:auto;
    }
    canvas{
      position:absolute;
      top:0; left:0;
      max-width:none; max-height:none; background:#0a0f1c; image-rendering: optimizeQuality;
      transform-origin: top left;
      backface-visibility: hidden;
      will-change: transform;
      display:block;
      transform: translateZ(0) scale(1);
      touch-action: auto;
    }

    .zoombar{
      position:sticky; top:8px; left:0; display:flex; align-items:center; justify-content:flex-end;
      gap:6px; padding:0 8px; pointer-events:none;
      z-index:2; flex-wrap:wrap;
    }
    .zoombar .zbtn{
      pointer-events:auto;
      background:rgba(10,15,28,.85); border:1px solid var(--border);
      border-radius:10px; padding:8px 10px; font-weight:700; cursor:pointer; min-height:36px;
      color:#e6edf6;
    }
    .zoom-readout{
      position:sticky; top:8px; left:8px; pointer-events:none; font-size:12px; color:#9fb0ca;
      background:rgba(10,15,28,.7); border:1px solid var(--border); border-radius:8px; padding:6px 8px;
      display:inline-block;
    }

    .sticky-footer{
      position: sticky;
      bottom: max(8px, var(--safe-bottom));
      z-index: 3;
      background: linear-gradient(180deg, rgba(19,23,34,0.0) 0%, rgba(19,23,34,0.85) 35%, rgba(19,23,34,0.95) 100%);
      padding: 10px 12px;
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 12px;
      backdrop-filter: blur(6px);
    }
    .sticky-footer .row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; }
    .sticky-footer .muted{ color:#c9d5ea; font-weight:700; }

    .row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; }
    .controls{ display:grid; gap:10px; }

    label{ font-size:12px; color:var(--muted); }
    input[type="range"], select, input[type="number"], input[type="text"], input[type="color"]{
      width:100%; background:#0b1020; color:#e6edf6; border:1px solid var(--border);
      border-radius:10px; padding:10px; min-height:44px;
    }
    input[type="checkbox"]{ transform: translateY(2px); width:18px; height:18px; }

    .drop{
      background:#0f1421; border:2px dashed #2a3955; border-radius:12px;
      padding:14px; text-align:center; color:#8b9bb3;
      transition:.2s ease; cursor:pointer;
    }
    .drop.compact{ padding:12px; font-size:.9rem; }
    .drop:hover{ border-color:var(--accent); color:#cbd6ea; }
    .drop.dragover{ background:#0b1220; border-color:#a6da95; }

    .thumbs{
      display:grid; grid-template-columns: repeat(auto-fill, minmax(88px, 1fr)); gap:8px;
    }
    .thumb{ position:relative; border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#0b1020; }
    .thumb img{ display:block; width:100%; height:70px; object-fit:cover; }
    .thumb .name{ font-size:10px; color:#8b9bb3; padding:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .thumb .pick,.thumb .trash{
      position:absolute; top:6px; background:rgba(0,0,0,.5); border:1px solid var(--border);
      padding:4px 8px; border-radius:999px; font-size:11px; cursor:pointer; min-height:28px;
    }
    .thumb .pick{ right:6px; } .thumb .trash{ left:6px; }

    #logo-thumbs .thumb img{ height:60px; }
    #logo-thumbs .thumb .name{ font-size:9px; }

    @media (max-width:980px){
      header{ grid-template-columns: 1fr; }
      .mobile-tabs{ display:flex; }

      .wrap{ grid-template-columns: 1fr; }
      .pane{ display:none; }
      .pane.active{ display:flex; }

      details.card{ overflow:hidden; }
      details.card:not([open]) .body{ display:none; }

      .thumbs{ display:flex; gap:8px; overflow:auto; padding-bottom:2px; }
      .thumb{ flex:0 0 120px; }
      .preview{ height: 45vh; }
    }
  </style>
</head>
<body>
  <header id="appHeader">
    <div class="head-left">
      <h1>Watermark Studio</h1>
      <div class="sub">Drag & drop your logo and photos • Add text • Position, tilt, and save templates</div>
    </div>

    <details class="actions-card" id="actions-details">
      <summary>Export &amp; Save</summary>
      <div class="head-actions">
        <button class="btn" id="btn-export">Download Current</button>
        <button class="btn primary" id="btn-export-all">Process All as ZIP</button>
        <button class="btn warn" id="btn-remove-current" title="Remove current photo from list">Remove Current</button>

        <button class="btn accent" id="btn-choose-dir" title="Pick a folder to save images into">Choose Save Folder</button>
        <button class="btn" id="btn-save-current-to-dir" disabled>Save Current to Folder</button>
        <button class="btn" id="btn-save-all-to-dir" disabled>Process All to Folder</button>
        <span class="note" id="dir-note"></span>
      </div>
    </details>

    <div class="mobile-tabs" role="tablist" aria-label="View switch">
      <button class="tab" id="tab-preview" aria-selected="false">Preview</button>
      <button class="tab active" id="tab-controls" aria-selected="true">Controls</button>
    </div>
  </header>

  <div class="wrap">
    <!-- LEFT: CONTROLS -->
    <div class="col controls-panel pane active" id="pane-controls" aria-labelledby="tab-controls">
      <div class="controls-scroll">

        <details class="card templates" open>
          <summary>Templates</summary>
          <div class="body">
            <div class="row" style="grid-template-columns: 1fr auto;">
              <input type="text" id="tpl-name" placeholder="Template name" />
              <button class="btn" id="btn-save-tpl">Save</button>
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <button class="btn" id="btn-export-tpl" title="Save template to a .json file">Export Template</button>
              <input id="tpl-import-input" type="file" accept="application/json" style="display:none" />
              <button class="btn" id="btn-import-tpl" title="Load template from a .json file">Import Template</button>
              <button class="btn warn" id="btn-clear-templates" title="Delete ALL saved templates">Clear All</button>
            </div>
            <div id="tpl-list" class="controls"></div>
          </div>
        </details>

        <details class="card watermark">
          <summary>Watermark (Logo)</summary>
          <div class="body">
            <div id="logo-drop" class="drop compact" tabindex="0">
              <div><strong>Add logo</strong> — tap to browse or drop</div>
              <div class="muted">PNG with transparency works best</div>
              <input id="logo-input" type="file" accept="image/*" style="display:none" />
            </div>

            <div class="thumbs" id="logo-thumbs"></div>

            <div class="controls">
              <div class="row">
                <label>Scale (% of photo width)</label>
                <input id="scale" type="range" min="1" max="100" value="25" />
              </div>
              <div class="row">
                <label>Opacity</label>
                <input id="opacity" type="range" min="1" max="100" value="70" />
              </div>
              <div class="row">
                <label>Anchor</label>
                <select id="anchor">
                  <option value="top-left">Top Left</option>
                  <option value="top-center">Top Center</option>
                  <option value="top-right">Top Right</option>
                  <option value="center-left">Center Left</option>
                  <option value="center">Center</option>
                  <option value="center-right">Center Right</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="bottom-center" selected>Bottom Center</option>
                  <option value="bottom-right">Bottom Right</option>
                </select>
              </div>
              <div class="row">
                <label>Offset X (px)</label>
                <input id="offsetX" type="number" value="0" />
              </div>
              <div class="row">
                <label>Offset Y (px)</label>
                <input id="offsetY" type="number" value="-20" />
              </div>
              <div class="row">
                <label>Allow drag on preview</label>
                <input id="dragToggle" type="checkbox" checked />
              </div>
            </div>
          </div>
        </details>

        <details class="card photos">
          <summary>Photos</summary>
          <div class="body">
            <div id="photo-drop" class="drop compact" tabindex="0">
              <div><strong>Add photos</strong> — tap to browse or drop</div>
              <div class="muted">JPG/PNG; you can add multiple</div>
              <input id="photo-input" type="file" accept="image/*" multiple style="display:none" />
            </div>
            <div class="thumbs" id="photo-thumbs"></div>
          </div>
        </details>

        <details class="card textmark">
          <summary>Text Watermark</summary>
          <div class="body">
            <div class="controls">
              <div class="row">
                <label>Text</label>
                <input id="txt-text" type="text" placeholder="Type your watermark text" />
              </div>
              <div class="row">
                <label>Font family</label>
                <select id="txt-font">
                  <option value="Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial">Sans</option>
                  <option value="Georgia, 'Times New Roman', Times, serif">Serif</option>
                  <option value="'Courier New', Courier, monospace">Mono</option>
                </select>
              </div>
              <div class="row">
                <label>Size (px)</label>
                <input id="txt-size" type="number" value="48" min="6" />
              </div>
              <div class="row">
                <label>Color</label>
                <input id="txt-color" type="color" value="#ffffff" />
              </div>
              <div class="row">
                <label>Opacity</label>
                <input id="txt-opacity" type="range" min="1" max="100" value="70" />
              </div>
              <div class="row">
                <label>Tilt (°)</label>
                <input id="txt-rot" type="range" min="-180" max="180" value="0" />
              </div>

              <div class="row">
                <label>Text Anchor</label>
                <select id="txt-anchor">
                  <option value="top-left">Top Left</option>
                  <option value="top-center">Top Center</option>
                  <option value="top-right">Top Right</option>
                  <option value="center-left">Center Left</option>
                  <option value="center">Center</option>
                  <option value="center-right">Center Right</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="bottom-center">Bottom Center</option>
                  <option value="bottom-right">Bottom Right</option>
                </select>
              </div>
              <div class="row">
                <label>Text Offset X (px)</label>
                <input id="txt-offx" type="number" value="0" />
              </div>
              <div class="row">
                <label>Text Offset Y (px)</label>
                <input id="txt-offy" type="number" value="0" />
              </div>

              <div style="display:flex; gap:8px; flex-wrap:wrap;">
                <button class="btn" id="btn-reset-tilt">Reset Tilt</button>
                <label style="display:flex; align-items:center; gap:8px;">
                  <span class="muted">Enable text drag</span>
                  <input id="txt-drag-toggle" type="checkbox" checked />
                </label>
              </div>
            </div>
          </div>
        </details>

      </div>
    </div>

    <!-- RIGHT: PREVIEW -->
    <div class="col pane" id="pane-preview" aria-labelledby="tab-preview">
      <div class="card">
        <h2>Preview</h2>
        <div class="body">
          <div class="preview" id="preview">
            <div class="zoombar" id="zoombar">
              <button class="zbtn" id="zoom-out" title="Zoom out (Ctrl/⌘ + scroll)">−</button>
              <button class="zbtn" id="zoom-in"  title="Zoom in (Ctrl/⌘ + scroll)">+</button>
              <button class="zbtn" id="zoom-fit" title="Fit to screen">Fit</button>
              <button class="zbtn" id="zoom-100" title="Actual size">100%</button>
            </div>
            <div class="zoom-readout" id="zoom-readout">100%</div>
            <canvas id="canvas"></canvas>
          </div>

          <div class="sticky-footer">
            <div class="row">
              <div class="muted">Format</div>
              <select id="format">
                <option value="image/jpeg" selected>JPEG</option>
                <option value="image/png">PNG</option>
              </select>
            </div>
          </div>

        </div>
      </div>
    </div>
  </div>

  <!-- libs -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <script>
    /* Header height calibration for sticky layout */
    (function calibrateHeader() {
      const header = document.getElementById('appHeader');
      const set = () => {
        const h = Math.round(header.getBoundingClientRect().height);
        document.documentElement.style.setProperty('--headH', h + 'px');
      };
      set();
      new ResizeObserver(set).observe(header);
      window.addEventListener('orientationchange', set);
      window.addEventListener('resize', set);
      document.getElementById('actions-details').addEventListener('toggle', set);
    })();

    /* Mobile tab switch — default to CONTROLS on mobile */
    (function tabs(){
      const tabPrev = document.getElementById('tab-preview');
      const tabCtrl = document.getElementById('tab-controls');
      const panePrev = document.getElementById('pane-preview');
      const paneCtrl = document.getElementById('pane-controls');

      function activate(which){
        const isPrev = which === 'preview';
        tabPrev.classList.toggle('active', isPrev);
        tabPrev.setAttribute('aria-selected', isPrev);
        panePrev.classList.toggle('active', isPrev);

        tabCtrl.classList.toggle('active', !isPrev);
        tabCtrl.setAttribute('aria-selected', !isPrev);
        paneCtrl.classList.toggle('active', !isPrev);
      }

      tabPrev?.addEventListener('click', () => activate('preview'));
      tabCtrl?.addEventListener('click', () => activate('controls'));

      const mm = window.matchMedia('(max-width: 980px)');
      const handle = () => {
        if (mm.matches) activate('controls');
        else { panePrev.classList.add('active'); paneCtrl.classList.add('active'); }
      };
      handle(); mm.addEventListener('change', handle);
    })();

    // ---------- State ----------
    const state = {
      logoImg: null,
      logoName: '',
      photos: [], // {name, img}
      currentIndex: -1,
      settings: { scalePct: 25, opacity: 0.7, anchor: 'bottom-center', offsetX: 0, offsetY: -20 },
      drag:   { enabled: true, active: false, dx:0, dy:0, id:null },
      text:   {
        value: '', fontFamily: "Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
        sizePx: 48, color: '#ffffff', opacity: 0.7, rotDeg: 0,
        anchor: 'center', offsetX: 0, offsetY: 0,
        dragEnabled: true, drag: { active:false, dx:0, dy:0, id:null }
      },
      outDir: null, outDirName: '',
      zoom: 1, zoomMode: 'fit'
    };

    // ---------- Elements ----------
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
    ctx.imageSmoothingEnabled = true;

    const previewEl = document.getElementById('preview');
    const zoomReadout = document.getElementById('zoom-readout');

    const logoDrop = document.getElementById('logo-drop');
    const logoInput = document.getElementById('logo-input');
    const logoThumbs = document.getElementById('logo-thumbs');

    const photoDrop = document.getElementById('photo-drop');
    const photoInput = document.getElementById('photo-input');
    const thumbs = document.getElementById('photo-thumbs');

    const scaleEl = document.getElementById('scale');
    const opacityEl = document.getElementById('opacity');
    const anchorEl = document.getElementById('anchor');
    const offsetXEl = document.getElementById('offsetX');
    const offsetYEl = document.getElementById('offsetY');
    const dragToggle = document.getElementById('dragToggle');
    const formatEl = document.getElementById('format');

    const exportBtn = document.getElementById('btn-export');
    const exportAllBtn = document.getElementById('btn-export-all');
    const removeCurrentBtn = document.getElementById('btn-remove-current');

    const chooseDirBtn = document.getElementById('btn-choose-dir');
    const saveCurrentToDirBtn = document.getElementById('btn-save-current-to-dir');
    const saveAllToDirBtn = document.getElementById('btn-save-all-to-dir');
    const dirNote = document.getElementById('dir-note');

    const txtTextEl = document.getElementById('txt-text');
    const txtFontEl = document.getElementById('txt-font');
    const txtSizeEl = document.getElementById('txt-size');
    const txtColorEl = document.getElementById('txt-color');
    const txtOpacityEl = document.getElementById('txt-opacity');
    const txtRotEl = document.getElementById('txt-rot');
    const txtDragToggle = document.getElementById('txt-drag-toggle');
    const resetTiltBtn = document.getElementById('btn-reset-tilt');
    const txtAnchorEl = document.getElementById('txt-anchor');
    const txtOffXEl  = document.getElementById('txt-offx');
    const txtOffYEl  = document.getElementById('txt-offy');

    const zIn = document.getElementById('zoom-in');
    const zOut = document.getElementById('zoom-out');
    const zFit = document.getElementById('zoom-fit');
    const z100 = document.getElementById('zoom-100');

    // ---------- Helpers ----------
    const raf = (()=>{ let p=false; return (fn)=>{ if(p) return; p=true; requestAnimationFrame(()=>{ p=false; fn(); }); }; })();

    function readAsImage(file){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => {
          const img = new Image();
          img.onload = () => resolve({ img, name:file.name });
          img.onerror = reject;
          img.src = fr.result;
        };
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });
    }

    // ---------- Geometry (LOGO) ----------
    function logoDims(){
      if (!state.logoImg || !state.photos[state.currentIndex]) return { w:0, h:0 };
      const targetW = canvas.width * (state.settings.scalePct / 100);
      const aspect = state.logoImg.naturalWidth / state.logoImg.naturalHeight;
      return { w: targetW, h: targetW / aspect };
    }
    function logoBasePos(){
      const { w, h } = logoDims();
      const cx = canvas.width/2, cy = canvas.height/2;
      switch (state.settings.anchor){
        case 'top-left':     return { x:0, y:0 };
        case 'top-center':   return { x:cx - w/2, y:0 };
        case 'top-right':    return { x:canvas.width - w, y:0 };
        case 'center-left':  return { x:0, y:cy - h/2 };
        case 'center':       return { x:cx - w/2, y:cy - h/2 };
        case 'center-right': return { x:canvas.width - w, y:cy - h/2 };
        case 'bottom-left':  return { x:0, y:canvas.height - h };
        case 'bottom-center':return { x:cx - w/2, y:canvas.height - h };
        case 'bottom-right': return { x:canvas.width - w, y:canvas.height - h };
      }
      return { x:0, y:0 };
    }
    function getLogoAbs(){
      const base = logoBasePos();
      return { x: base.x + Number(state.settings.offsetX||0), y: base.y + Number(state.settings.offsetY||0) };
    }
    function setLogoAbs(x, y){
      const base = logoBasePos();
      state.settings.offsetX = Math.round(x - base.x);
      state.settings.offsetY = Math.round(y - base.y);
      offsetXEl.value = state.settings.offsetX;
      offsetYEl.value = state.settings.offsetY;
      raf(draw);
    }
    function setLogoAnchorSnap(newAnchor){
      state.settings.anchor = newAnchor;
      state.settings.offsetX = 0;
      state.settings.offsetY = 0;
      offsetXEl.value = 0; offsetYEl.value = 0;
      raf(draw);
    }

    // ---------- Geometry (TEXT) ----------
    function measureTextSize(){
      const tctx = document.createElement('canvas').getContext('2d');
      tctx.font = `${state.text.sizePx}px ${state.text.fontFamily}`;
      const w = Math.ceil(tctx.measureText(state.text.value || '').width);
      const h = state.text.sizePx;
      return { w, h };
    }
    function textBasePos(){
      const { w, h } = measureTextSize();
      const cx = canvas.width/2, cy = canvas.height/2;
      switch (state.text.anchor){
        case 'top-left':     return { x:0, y:0 };
        case 'top-center':   return { x:cx - w/2, y:0 };
        case 'top-right':    return { x:canvas.width - w, y:0 };
        case 'center-left':  return { x:0, y:cy - h/2 };
        case 'center':       return { x:cx - w/2, y:cy - h/2 };
        case 'center-right': return { x:canvas.width - w, y:cy - h/2 };
        case 'bottom-left':  return { x:0, y:canvas.height - h };
        case 'bottom-center':return { x:cx - w/2, y:canvas.height - h };
        case 'bottom-right': return { x:canvas.width - w, y:canvas.height - h };
      }
      return { x:0, y:0 };
    }
    function getTextAbs(){ const b = textBasePos(); return { x: b.x + Number(state.text.offsetX||0), y: b.y + Number(state.text.offsetY||0) }; }
    function setTextAbs(x, y){ const b = textBasePos(); state.text.offsetX = Math.round(x - b.x); state.text.offsetY = Math.round(y - b.y); txtOffXEl.value = state.text.offsetX; txtOffYEl.value = state.text.offsetY; raf(draw); }
    function setTextAnchorSnap(newAnchor){ state.text.anchor = newAnchor; state.text.offsetX = 0; state.text.offsetY = 0; txtOffXEl.value = 0; txtOffYEl.value = 0; raf(draw); }

    // ---------- Zoom ----------
    function computeFitZoom(){
      if (!canvas.width || !canvas.height) return 1;
      const pad = 16;
      const availW = Math.max(100, previewEl.clientWidth - pad);
      const availH = Math.max(100, previewEl.clientHeight - pad);
      return Math.min(availW / canvas.width, availH / canvas.height);
    }
    function applyZoom(){
      if (state.zoomMode === 'fit') state.zoom = computeFitZoom();
      const z = Math.round(state.zoom * 100) / 100; // avoid tile seams
      canvas.style.transform = `translateZ(0) scale(${z})`;
      zoomReadout.textContent = `${Math.round(z*100)}%`;
    }
    function setZoom(z, mode='manual'){
      state.zoom = Math.min(8, Math.max(0.05, z));
      state.zoomMode = mode;
      applyZoom();
    }
    function zoomStep(dir){ const step = dir > 0 ? 1.1 : 1/1.1; setZoom(state.zoom * step, 'manual'); }
    new ResizeObserver(() => { if (state.zoomMode==='fit') applyZoom(); }).observe(previewEl);

    // ---------- Drawing / performance ----------
    function ensureCanvasSize(w, h){
      if (canvas.width !== w || canvas.height !== h){
        canvas.width = w; canvas.height = h;
      }
    }
    function draw(){
      const photo = state.photos[state.currentIndex];
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (!photo) { applyZoom(); return; }

      // Resize only when necessary (huge perf win while dragging)
      ensureCanvasSize(photo.img.naturalWidth, photo.img.naturalHeight);

      // Base photo
      ctx.globalCompositeOperation = 'source-over';
      ctx.drawImage(photo.img, 0, 0);

      // Logo
      if (state.logoImg){
        const { w, h } = logoDims();
        const p = getLogoAbs();
        ctx.globalAlpha = state.settings.opacity;
        ctx.drawImage(state.logoImg, p.x, p.y, w, h);
        ctx.globalAlpha = 1;
      }

      // Text
      if (state.text.value){
        const p = getTextAbs();
        const t = state.text;
        ctx.save();
        ctx.globalAlpha = t.opacity;
        ctx.font = `${t.sizePx}px ${t.fontFamily}`;
        ctx.fillStyle = t.color;
        ctx.textBaseline = 'top';
        ctx.translate(p.x, p.y);
        ctx.rotate((t.rotDeg || 0) * Math.PI / 180);
        ctx.fillText(t.value, 0, 0);
        ctx.restore();
      }

      applyZoom();
    }

    function setCurrent(index){ state.currentIndex = index; const p = state.photos[index]; if (p) ensureCanvasSize(p.img.naturalWidth, p.img.naturalHeight); raf(draw); }

    // ---------- Thumbnails ----------
    function refreshPhotoThumbs(){
      thumbs.innerHTML = '';
      state.photos.forEach((p,i) => {
        const div = document.createElement('div');
        div.className = 'thumb';
        div.innerHTML = `<img alt="thumb"/><div class="name">${p.name}</div><div class="pick">Use</div><div class="trash">Del</div>`;
        div.querySelector('img').src = p.img.src;
        div.querySelector('.pick').onclick = () => setCurrent(i);
        div.querySelector('.trash').onclick = () => removePhotoAt(i);
        thumbs.appendChild(div);
      });
      if (state.currentIndex === -1 && state.photos.length) setCurrent(0);
    }
    function renderLogoThumb(){
      logoThumbs.innerHTML = '';
      if (!state.logoImg) return;
      const div = document.createElement('div');
      div.className = 'thumb';
      div.innerHTML = `
        <img alt="logo-thumb"/>
        <div class="name">${state.logoName || 'Logo'}</div>
        <div class="pick">Replace</div>
        <div class="trash">Clear</div>
      `;
      div.querySelector('img').src = state.logoImg.src;
      div.querySelector('.pick').onclick = () => logoInput.click();
      div.querySelector('.trash').onclick = () => { state.logoImg = null; state.logoName=''; renderLogoThumb(); raf(draw); };
      logoThumbs.appendChild(div);
    }

    function removePhotoAt(i){
      if (i < 0 || i >= state.photos.length) return;
      state.photos.splice(i,1);
      if (!state.photos.length){
        state.currentIndex = -1; ctx.clearRect(0,0,canvas.width,canvas.height);
      } else if (state.currentIndex >= state.photos.length){
        state.currentIndex = state.photos.length - 1;
      }
      refreshPhotoThumbs(); raf(draw);
    }

    function bindDropzone(zoneEl, inputEl, onFiles){
      const openPicker = () => inputEl.click();
      zoneEl.addEventListener('click', openPicker);
      zoneEl.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') openPicker(); });
      zoneEl.addEventListener('dragover', e => { e.preventDefault(); zoneEl.classList.add('dragover'); });
      zoneEl.addEventListener('dragleave', () => zoneEl.classList.remove('dragover'));
      zoneEl.addEventListener('drop', async e => {
        e.preventDefault(); zoneEl.classList.remove('dragover');
        const files = [...e.dataTransfer.files].filter(f => f.type.startsWith('image/'));
        if (files.length) onFiles(files);
      });
      inputEl.addEventListener('change', () => {
        const files = [...inputEl.files];
        if (files.length) onFiles(files);
        inputEl.value='';
      });
    }

    bindDropzone(logoDrop, logoInput, async files => {
      const f = files[0];
      const { img, name } = await readAsImage(f);
      state.logoImg = img; state.logoName = name || 'Logo';
      renderLogoThumb(); raf(draw);
    });

    bindDropzone(photoDrop, photoInput, async files => {
      for (const f of files){
        const { img, name } = await readAsImage(f);
        state.photos.push({ img, name });
      }
      refreshPhotoThumbs(); raf(draw);
    });

    // ---------- Pointer interactions (drag) ----------
    function getPointerCanvasXY(e){
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
    }
    function measureTextRectForHit(){
      if (!state.text.value) return null;
      const tctx = document.createElement('canvas').getContext('2d');
      tctx.font = `${state.text.sizePx}px ${state.text.fontFamily}`;
      const w = Math.ceil(tctx.measureText(state.text.value).width);
      const h = state.text.sizePx;
      const p = getTextAbs();
      const rad = (state.text.rotDeg||0) * Math.PI/180;
      const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
      return { x:p.x, y:p.y, w:Math.ceil(w*cos + h*sin), h:Math.ceil(w*sin + h*cos) };
    }
    function pointInRect(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

    let dragTarget = null; // 'text' | 'logo'
    let lastTapTime = 0;

    canvas.addEventListener('pointerdown', (e) => {
      if (state.currentIndex === -1) return;

      const now = Date.now();
      if (now - lastTapTime < 300){
        const step = 1.1; setZoom(state.zoom * step, 'manual');
        lastTapTime = 0;
        return;
      }
      lastTapTime = now;

      const { x, y } = getPointerCanvasXY(e);

      // TEXT drag?
      const tr = measureTextRectForHit();
      if (state.text.dragEnabled && tr && pointInRect(x,y,tr)){
        e.preventDefault();
        dragTarget = 'text';
        state.text.drag.active = true;
        state.text.drag.id = e.pointerId;
        const p = getTextAbs();
        state.text.drag.dx = x - p.x;
        state.text.drag.dy = y - p.y;
        canvas.setPointerCapture(e.pointerId);
        // lock scroll while dragging for smoother motion
        previewEl.dataset.prevOverflow = previewEl.style.overflow || '';
        previewEl.style.overflow = 'hidden';
        canvas.style.touchAction = 'none';
        return;
      }

      // LOGO drag?
      if (state.drag.enabled && state.logoImg){
        const { w, h } = logoDims();
        const p = getLogoAbs();
        const r = { x:p.x, y:p.y, w, h };
        if (pointInRect(x,y,r)){
          e.preventDefault();
          dragTarget = 'logo';
          state.drag.active = true;
          state.drag.id = e.pointerId;
          state.drag.dx = x - p.x;
          state.drag.dy = y - p.y;
          canvas.setPointerCapture(e.pointerId);
          previewEl.dataset.prevOverflow = previewEl.style.overflow || '';
          previewEl.style.overflow = 'hidden';
          canvas.style.touchAction = 'none';
        }
      }
    }, { passive:false });

    canvas.addEventListener('pointermove', (e) => {
      if (e.pointerId !== state.drag.id && e.pointerId !== state.text.drag.id) return;
      const { x, y } = getPointerCanvasXY(e);
      if (dragTarget === 'text' && state.text.drag.active){
        e.preventDefault();
        setTextAbs(Math.round(x - state.text.drag.dx), Math.round(y - state.text.drag.dy));
      } else if (dragTarget === 'logo' && state.drag.active){
        e.preventDefault();
        setLogoAbs(Math.round(x - state.drag.dx), Math.round(y - state.drag.dy));
      }
    }, { passive:false });

    function endDrag(){
      dragTarget = null;
      state.drag.active = false; state.drag.id = null;
      state.text.drag.active = false; state.text.drag.id = null;
      // restore scroll/gesture
      canvas.style.touchAction = 'auto';
      previewEl.style.overflow = previewEl.dataset.prevOverflow || '';
      delete previewEl.dataset.prevOverflow;
    }
    canvas.addEventListener('pointerup', endDrag, { passive:true });
    canvas.addEventListener('pointercancel', endDrag, { passive:true });
    canvas.addEventListener('lostpointercapture', endDrag, { passive:true });

    // ---------- Controls — Logo ----------
    scaleEl.addEventListener('input', () => { state.settings.scalePct = Number(scaleEl.value); raf(draw); });
    opacityEl.addEventListener('input', () => { state.settings.opacity = Number(opacityEl.value)/100; raf(draw); });
    anchorEl.addEventListener('change', () => setLogoAnchorSnap(anchorEl.value));
    offsetXEl.addEventListener('input', () => { state.settings.offsetX = Number(offsetXEl.value||0); raf(draw); });
    offsetYEl.addEventListener('input', () => { state.settings.offsetY = Number(offsetYEl.value||0); raf(draw); });
    dragToggle.addEventListener('change', () => { state.drag.enabled = dragToggle.checked; });

    // ---------- Controls — Text ----------
    txtTextEl.addEventListener('input', () => { state.text.value = txtTextEl.value; raf(draw); });
    txtFontEl.addEventListener('change', () => { state.text.fontFamily = txtFontEl.value; raf(draw); });
    txtSizeEl.addEventListener('input', () => { state.text.sizePx = Math.max(6, Number(txtSizeEl.value||0)); raf(draw); });
    txtColorEl.addEventListener('input', () => { state.text.color = txtColorEl.value; raf(draw); });
    txtOpacityEl.addEventListener('input', () => { state.text.opacity = Number(txtOpacityEl.value)/100; raf(draw); });
    txtRotEl.addEventListener('input', () => { state.text.rotDeg = Number(txtRotEl.value); raf(draw); });
    txtAnchorEl.addEventListener('change', () => setTextAnchorSnap(txtAnchorEl.value));
    txtOffXEl.addEventListener('input', () => { state.text.offsetX = Number(txtOffXEl.value||0); raf(draw); });
    txtOffYEl.addEventListener('input', () => { state.text.offsetY = Number(txtOffYEl.value||0); raf(draw); });
    txtDragToggle.addEventListener('change', () => { state.text.dragEnabled = txtDragToggle.checked; });
    resetTiltBtn.addEventListener('click', () => { state.text.rotDeg = 0; txtRotEl.value = 0; raf(draw); });

    removeCurrentBtn.addEventListener('click', () => { if (state.currentIndex !== -1) removePhotoAt(state.currentIndex); });

    // ---------- Zoom controls ----------
    const previewElRef = document.getElementById('preview');
    previewElRef.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey){
        e.preventDefault();
        if (e.deltaY < 0) zoomStep(+1); else zoomStep(-1);
      }
    }, { passive:false });
    zIn.addEventListener('click',  () => zoomStep(+1));
    zOut.addEventListener('click', () => zoomStep(-1));
    zFit.addEventListener('click', () => setZoom(computeFitZoom(), 'fit'));
    z100.addEventListener('click', () => setZoom(1, 'manual'));

    // ---------- Export ----------
    function downloadCurrent(){
      const photo = state.photos[state.currentIndex];
      if (!photo) return alert('Add a photo first.');
      const mime = formatEl.value;
      const name = photo.name.replace(/\.[^.]+$/, '');
      raf(() => {
        canvas.toBlob((blob) => {
          if (!blob) return;
          const ext = mime === 'image/png' ? 'png' : 'jpg';
          try{
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `${name}_watermarked.${ext}`;
            a.click();
            URL.revokeObjectURL(a.href);
          }catch{
            saveAs(blob, `${name}_watermarked.${ext}`);
          }
        }, mime, mime === 'image/jpeg' ? 0.92 : undefined);
      });
    }

    async function processAllZip(){
      if (!state.photos.length) return alert('Add some photos first.');
      if (typeof JSZip === 'undefined'){ alert('JSZip not loaded. Try again or download individually.'); return; }
      const zip = new JSZip();
      const mime = formatEl.value;
      for (let i=0;i<state.photos.length;i++){
        setCurrent(i);
        await new Promise(r => requestAnimationFrame(r));
        const blob = await new Promise(res => canvas.toBlob(res, mime, mime === 'image/jpeg' ? 0.92 : undefined));
        const base = state.photos[i].name.replace(/\.[^.]+$/, '');
        const name = `${base}_watermarked${mime==='image/png'?'.png':'.jpg'}`;
        zip.file(name, blob);
      }
      const out = await zip.generateAsync({ type:'blob' });
      try{
        const handle = await window.showSaveFilePicker({
          suggestedName:'watermarked_photos.zip',
          types:[{ description:'ZIP Archive', accept:{'application/zip':['.zip']} }]
        });
        const writable = await handle.createWritable();
        await writable.write(out); await writable.close();
      }catch(e){
        saveAs(out, 'watermarked_photos.zip');
      }
    }

    document.getElementById('btn-export').addEventListener('click', downloadCurrent);
    document.getElementById('btn-export-all').addEventListener('click', processAllZip);

    // ---------- Save-to-folder helpers ----------
    function fsSupported(){ return 'showDirectoryPicker' in window; }
    function updateDirUI(){
      const on = !!state.outDir;
      saveCurrentToDirBtn.disabled = !on;
      saveAllToDirBtn.disabled = !on;
      dirNote.textContent = on ? `Saving to: ${state.outDirName}` :
        (fsSupported() ? 'Pick a folder to save images there.' : 'Folder saving not supported in this browser.');
    }
    async function ensureDirPermission(){
      if (!state.outDir) return false;
      if (!state.outDir.queryPermission) return true;
      const q = await state.outDir.queryPermission({ mode:'readwrite' });
      if (q === 'granted') return true;
      if (q === 'prompt'){
        const r = await state.outDir.requestPermission({ mode:'readwrite' });
        return r === 'granted';
      }
      return false;
    }
    chooseDirBtn.addEventListener('click', async () => {
      if (!fsSupported()){ alert('Your browser does not support choosing a save folder. Try Chrome/Edge.'); return; }
      try{
        const dir = await window.showDirectoryPicker({ mode:'readwrite' });
        state.outDir = dir;
        state.outDirName = dir.name || 'Selected Folder';
        const ok = await ensureDirPermission();
        if (!ok){ alert('Permission denied for that folder.'); state.outDir = null; }
      }catch(e){ /* cancelled */ }
      updateDirUI();
    });
    async function saveBlobToDir(filename, blob){
      if (!await ensureDirPermission()){ alert('No permission to write to the chosen folder.'); return; }
      async function fileExists(dir, name){ try{ await dir.getFileHandle(name, { create:false }); return true; } catch{ return false; } }
      function splitName(filename){ const i=filename.lastIndexOf('.'); return i>0?{base:filename.slice(0,i),ext:filename.slice(i)}:{base:filename,ext:''}; }
      async function uniqueName(dir, desired){
        if (!(await fileExists(dir, desired))) return desired;
        const { base, ext } = splitName(desired);
        for (let i=1;i<10000;i++){ const cand = `${base} (${i})${ext}`; if (!(await fileExists(dir, cand))) return cand; }
        return `${base} (${Date.now()})${ext}`;
      }
      const finalName = await uniqueName(state.outDir, filename);
      const fileHandle = await state.outDir.getFileHandle(finalName, { create:true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob); await writable.close();
      return finalName;
    }
    async function saveCurrentToDir(){
      const photo = state.photos[state.currentIndex];
      if (!photo) return alert('Add a photo first.');
      const mime = formatEl.value;
      const base = photo.name.replace(/\.[^.]+$/, '');
      await new Promise(r => requestAnimationFrame(r)); // ensure draw
      const blob = await new Promise(res => canvas.toBlob(res, mime, mime === 'image/jpeg' ? 0.92 : undefined));
      const savedAs = await saveBlobToDir(`${base}_watermarked${mime==='image/png'?'.png':'.jpg'}`, blob);
      if (savedAs) dirNote.textContent = `Saved ${savedAs} to: ${state.outDirName}`;
    }
    async function saveAllToDir(){
      if (!state.photos.length) return alert('Add some photos first.');
      const mime = formatEl.value;
      for (let i=0;i<state.photos.length;i++){
        setCurrent(i);
        await new Promise(r => requestAnimationFrame(r));
        const base = state.photos[i].name.replace(/\.[^.]+$/, '');
        const blob = await new Promise(res => canvas.toBlob(res, mime, mime === 'image/jpeg' ? 0.92 : undefined));
        await saveBlobToDir(`${base}_watermarked${mime==='image/png'?'.png':'.jpg'}`, blob);
      }
      dirNote.textContent = `Saved ${state.photos.length} file(s) to: ${state.outDirName}`;
    }
    document.getElementById('btn-save-current-to-dir').addEventListener('click', saveCurrentToDir);
    document.getElementById('btn-save-all-to-dir').addEventListener('click', saveAllToDir);
    updateDirUI();

    // ---------- Templates (save / import / export) ----------
    const LS_KEY = 'wm_templates_v4';
    function getTemplates(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)) || []; } catch{ return []; } }
    function setTemplates(list){ localStorage.setItem(LS_KEY, JSON.stringify(list)); }

    function serializeTemplate(name){
      // keep only stable fields
      const { scalePct, opacity, anchor, offsetX, offsetY } = state.settings;
      const text = {
        value: state.text.value,
        fontFamily: state.text.fontFamily,
        sizePx: state.text.sizePx,
        color: state.text.color,
        opacity: state.text.opacity,
        rotDeg: state.text.rotDeg,
        anchor: state.text.anchor,
        offsetX: state.text.offsetX,
        offsetY: state.text.offsetY,
        dragEnabled: state.text.dragEnabled
      };
      let logoDataUrl = null;
      if (state.logoImg){
        try{
          const tmp = document.createElement('canvas');
          tmp.width = state.logoImg.naturalWidth; tmp.height = state.logoImg.naturalHeight;
          tmp.getContext('2d').drawImage(state.logoImg, 0, 0);
          logoDataUrl = tmp.toDataURL('image/png');
        }catch(e){
          // if tainted, skip embedding; user can re-add logo
          logoDataUrl = null;
        }
      }
      return { name, settings:{ scalePct, opacity, anchor, offsetX, offsetY }, logo:{ dataUrl:logoDataUrl }, text, createdAt:Date.now(), version:4 };
    }

    function saveTemplate(name){
      if (!name){ alert('Enter a template name.'); return; }
      const tpl = serializeTemplate(name);
      const list = getTemplates().filter(t => t.name !== name);
      list.unshift(tpl); setTemplates(list); renderTplList(); alert('Template saved.');
    }

    function applyTemplate(tpl){
      // allow old versions (v3)
      const tset = tpl.settings || {};
      state.settings = {
        ...state.settings,
        scalePct: Number(tset.scalePct ?? state.settings.scalePct),
        opacity: Number(tset.opacity ?? state.settings.opacity),
        anchor: tset.anchor ?? state.settings.anchor,
        offsetX: Number(tset.offsetX ?? state.settings.offsetX),
        offsetY: Number(tset.offsetY ?? state.settings.offsetY)
      };
      if (tpl.text){
        const tt = tpl.text;
        state.text = {
          ...state.text,
          value: tt.value ?? state.text.value,
          fontFamily: tt.fontFamily ?? state.text.fontFamily,
          sizePx: Number(tt.sizePx ?? state.text.sizePx),
          color: tt.color ?? state.text.color,
          opacity: Number(tt.opacity ?? state.text.opacity),
          rotDeg: Number(tt.rotDeg ?? state.text.rotDeg),
          anchor: tt.anchor ?? state.text.anchor,
          offsetX: Number(tt.offsetX ?? state.text.offsetX),
          offsetY: Number(tt.offsetY ?? state.text.offsetY),
          dragEnabled: Boolean(tt.dragEnabled ?? state.text.dragEnabled)
        };
      }
      if (tpl.logo && tpl.logo.dataUrl){
        const img = new Image();
        img.onload = () => { state.logoImg = img; state.logoName = 'Logo'; renderLogoThumb(); raf(draw); };
        img.src = tpl.logo.dataUrl;
      }else{
        // keep existing logo if any; user can clear if desired
      }
      syncControls(); raf(draw);
    }

    function deleteTemplate(name){
      if (!confirm(`Delete template "${name}"?`)) return;
      const list = getTemplates().filter(t => t.name !== name);
      setTemplates(list); renderTplList();
    }

    function renderTplList(){
      const list = getTemplates();
      const tplListEl = document.getElementById('tpl-list');
      tplListEl.innerHTML = '';
      if (!list.length){
        const p = document.createElement('div'); p.className='muted'; p.textContent='No templates yet.';
        tplListEl.appendChild(p); return;
      }
      list.forEach(t => {
        const row = document.createElement('div');
        row.className = 'template-row';
        const op = t.settings?.opacity != null ? Math.round(t.settings.opacity*100) : '';
        row.innerHTML = `
          <div>
            <div style="font-size:12px; font-weight:700;">${t.name}</div>
            <div class="muted" style="font-size:10px;">
              Scale ${t.settings?.scalePct ?? '?'}% · Logo ${op}% · ${t.settings?.anchor ?? '?'}${t.text?.value ? ' · Text ✓' : ''}
            </div>
          </div>
          <button class="btn" data-act="load">Load</button>
          <button class="btn" data-act="rename">Rename</button>
          <button class="btn" data-act="export">Export</button>
          <button class="btn warn" data-act="delete">Delete</button>
        `;
        row.querySelector('[data-act="load"]').onclick = () => applyTemplate(t);
        row.querySelector('[data-act="delete"]').onclick = () => deleteTemplate(t.name);
        row.querySelector('[data-act="rename"]').onclick = () => {
          const nn = prompt('New name', t.name); if (!nn) return;
          const list2 = getTemplates(); const idx = list2.findIndex(x => x.name === t.name);
          if (idx >= 0){ list2[idx].name = nn; setTemplates(list2); renderTplList(); }
        };
        row.querySelector('[data-act="export"]').onclick = () => {
          try{
            const blob = new Blob([JSON.stringify(t, null, 2)], { type:'application/json' });
            // prefer native anchor, fallback to FileSaver
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `${t.name || 'template'}.json`; a.click();
            URL.revokeObjectURL(url);
          }catch{
            const blob = new Blob([JSON.stringify(t, null, 2)], { type:'application/json' });
            saveAs(blob, `${t.name || 'template'}.json`);
          }
        };
        tplListEl.appendChild(row);
      });
    }

    document.getElementById('btn-save-tpl').addEventListener('click', () => saveTemplate(document.getElementById('tpl-name').value.trim()));

    document.getElementById('btn-export-tpl').addEventListener('click', () => {
      const name = document.getElementById('tpl-name').value.trim() || 'template';
      try{
        const blob = new Blob([JSON.stringify(serializeTemplate(name), null, 2)], { type:'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = `${name}.json`; a.click();
        URL.revokeObjectURL(url);
      }catch{
        const blob = new Blob([JSON.stringify(serializeTemplate(name), null, 2)], { type:'application/json' });
        saveAs(blob, `${name}.json`);
      }
    });

    document.getElementById('btn-import-tpl').addEventListener('click', () => document.getElementById('tpl-import-input').click());
    document.getElementById('tpl-import-input').addEventListener('change', () => {
      const f = document.getElementById('tpl-import-input').files[0]; if (!f) return;
      const fr = new FileReader();
      fr.onload = () => {
        try{
          const parsed = JSON.parse(fr.result);
          if (!parsed || typeof parsed !== 'object' || !parsed.settings){
            throw new Error('Not a valid template file.');
          }
          const list = getTemplates().filter(t => t.name !== parsed.name);
          list.unshift(parsed); setTemplates(list); renderTplList(); applyTemplate(parsed);
        }catch(e){ alert('Failed to import template: ' + (e?.message || e)); }
      };
      fr.onerror = () => alert('Failed to read file.');
      fr.readAsText(f);
      document.getElementById('tpl-import-input').value='';
    });

    // ---------- Sync UI ----------
    function syncControls(){
      scaleEl.value = state.settings.scalePct;
      opacityEl.value = Math.round(state.settings.opacity * 100);
      anchorEl.value = state.settings.anchor;
      offsetXEl.value = state.settings.offsetX;
      offsetYEl.value = state.settings.offsetY;
      dragToggle.checked = state.drag.enabled;

      txtTextEl.value = state.text.value;
      txtFontEl.value = state.text.fontFamily;
      txtSizeEl.value = state.text.sizePx;
      txtColorEl.value = state.text.color;
      txtOpacityEl.value = Math.round(state.text.opacity * 100);
      txtRotEl.value = state.text.rotDeg;
      txtDragToggle.checked = state.text.dragEnabled;
      txtAnchorEl.value = state.text.anchor;
      txtOffXEl.value = state.text.offsetX;
      txtOffYEl.value = state.text.offsetY;
    }

    (function init(){
      renderLogoThumb();
      refreshPhotoThumbs();
      renderTplList();
      syncControls();
      setZoom(1, 'fit');
    })();
  </script>
</body>
</html>
