<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Watermark Studio — Mobile + Zoom (No Slider)</title>
  <style>
    :root{
      --bg:#0b0d12; --panel:#131722; --muted:#8b9bb3; --text:#e6edf6;
      --accent:#7aa2f7; --accent-2:#a6da95; --border:#273042; --headH:66px;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    /* Prevent horizontal overflow (fixes preview getting cut off) */
    html, body { overflow-x: hidden; }
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: linear-gradient(180deg,#0b0d12 0%,#101521 100%);
      color:var(--text);
      height:100svh;
      overflow:hidden; /* vertical scroll handled inside columns */
    }
    @supports not (height:100svh){ body{ height:100vh; } }

    header{
      padding: calc(12px + var(--safe-top)) 16px 12px;
      border-bottom:1px solid var(--border);
      background:rgba(19,23,34,0.8);
      position:sticky; top:0; backdrop-filter: blur(6px);
      display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:center;
      z-index:10;
      min-width:0; max-width:100%;
    }
    header h1{ font-size:18px; margin:0; font-weight:700; letter-spacing:.2px; }
    header .sub{ color:var(--muted); font-size:12px; margin-top:2px; }
    .head-left{ display:flex; flex-direction:column; gap:2px; min-width:0; }
    .head-actions{
      display:flex; gap:8px; align-items:center;
      overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling:touch; padding-bottom:2px;
      min-width:0; max-width:100%;
    }
    .note{ color:var(--muted); font-size:12px; margin-left:4px; white-space:nowrap; }

    .btn{
      background:#1a2440; color:#fff; border:1px solid var(--border);
      padding:10px 12px; border-radius:12px; cursor:pointer; transition:.15s ease;
      font-weight:600; white-space:nowrap; flex:0 0 auto; min-height:44px;
    }
    .btn.primary{ background:#183055; border-color:#2b4e86; }
    .btn.accent{ background:var(--accent); color:#0b0d12; border:none; }
    .btn.warn{ background:#5b2330; border-color:#7b2d3f; }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn:hover:not(:disabled){ filter:brightness(1.05); transform:translateY(-1px); }
    .btn:active{ transform:translateY(0); }

    /* Tabs (mobile only) */
    .mobile-tabs{
      display:none; grid-column:1 / -1; margin-top:6px; gap:8px; max-width:100%;
    }
    .tab{
      flex:1 1 0; text-align:center; border-radius:999px; padding:8px 12px; font-weight:700;
      border:1px solid var(--border); background:#0f1421; cursor:pointer; min-height:40px;
    }
    .tab.active{ background:#1a2440; border-color:#2b4e86; }

    .wrap{
      display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:12px;
      height: calc(100svh - var(--headH) - var(--safe-bottom));
      overflow:hidden; min-height:0; width:100%; max-width:100%;
    }
    @supports not (height:100svh){
      .wrap{ height: calc(100vh - var(--headH)); }
    }
    .col{ display:flex; flex-direction:column; min-height:0; height:100%; min-width:0; }
    .col.controls-panel{ overflow:hidden; }
    .controls-scroll{
      height:100%; min-height:0; overflow:auto; -webkit-overflow-scrolling:touch;
      scrollbar-gutter: stable both-edges; padding-right:6px;
    }

    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; overflow:hidden; margin-bottom:12px; max-width:100%; }
    .card h2, .card summary{
      font-size:14px; letter-spacing:.3px; margin:0; padding:12px 14px;
      border-bottom:1px solid var(--border); color:#c9d5ea; list-style:none; cursor:default;
    }
    details.card > summary{ cursor:pointer; }
    details.card[open] > summary{ border-bottom:1px solid var(--border); }
    .card .body{ padding:12px; display:flex; flex-direction:column; gap:12px; }

    .drop{ background:#0f1421; border:2px dashed #2a3955; border-radius:12px; padding:14px; text-align:center; color:var(--muted); transition:.2s ease; cursor:pointer; }
    .drop:hover{ border-color:var(--accent); color:#cbd6ea; }
    .drop.dragover{ background:#0b1220; border-color:#a6da95; }

    .row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; }
    .controls{ display:grid; gap:10px; }

    label{ font-size:12px; color:var(--muted); }
    input[type="range"], select, input[type="number"], input[type="text"], input[type="color"]{
      width:100%; background:#0b1020; color:var(--text); border:1px solid var(--border);
      border-radius:10px; padding:10px; min-height:44px;
    }
    input[type="checkbox"]{ transform: translateY(2px); width:18px; height:18px; }

    /* Preview: containment + padding to avoid cutoffs */
    .preview{
      position:relative; background:#0a0f1c; border:1px solid var(--border);
      border-radius:14px; height:100%; overflow:auto; min-height:260px;
      padding:8px; contain: layout paint; isolation:isolate;
      touch-action: none; max-width:100%;
    }
    canvas{
      max-width:none; max-height:none; background:#0a0f1c; image-rendering: optimizeQuality;
      transform-origin: top left; touch-action: none; display:block;
    }

    /* Zoom toolbar (buttons only) */
    .zoombar{
      position:sticky; top:8px; left:0; display:flex; align-items:center; justify-content:flex-end;
      gap:6px; padding:0 8px; pointer-events:none; z-index:2; flex-wrap:wrap;
    }
    .zoombar .zbtn{
      pointer-events:auto; background:rgba(10,15,28,.85); border:1px solid var(--border);
      border-radius:10px; padding:8px 10px; font-weight:700; cursor:pointer; min-height:36px;
      color:#e6edf6;
    }

    .zoom-readout{
      position:sticky; top:8px; left:8px; pointer-events:none; font-size:12px; color:#9fb0ca;
      background:rgba(10,15,28,.7); border:1px solid var(--border); border-radius:8px; padding:6px 8px;
      display:inline-block;
    }

    .thumbs{
      display:grid; grid-template-columns: repeat(auto-fill, minmax(88px, 1fr)); gap:8px; max-height:28vh; overflow:auto;
    }
    .thumb{ position:relative; border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#0b1020; }
    .thumb img{ display:block; width:100%; height:70px; object-fit:cover; }
    .thumb .name{ font-size:10px; color:var(--muted); padding:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .thumb .pick,.thumb .trash{
      position:absolute; top:6px; background:rgba(0,0,0,.5); border:1px solid var(--border);
      padding:4px 8px; border-radius:999px; font-size:11px; cursor:pointer; min-height:28px;
    }
    .thumb .pick{ right:6px; } .thumb .trash{ left:6px; }

    .template-row{ display:grid; grid-template-columns: 1fr auto auto auto auto; gap:8px; align-items:center; }
    .muted{ color:var(--muted); font-size:12px; }

    @media (max-width:980px){
      header{ grid-template-columns: 1fr; }
      .head-actions{ order:3; flex-wrap:wrap; overflow:visible; row-gap:8px; }
      .head-actions .btn{ flex:1 1 calc(50% - 8px); }
      .note{ display:none; }

      .mobile-tabs{ display:flex; }
      .wrap{ grid-template-columns: 1fr; height: calc(100svh - var(--headH) - var(--safe-bottom)); }
      @supports not (height:100svh){
        .wrap{ height: calc(100vh - var(--headH)); }
      }

      .pane{ display:none; min-height:0; }
      .pane.active{ display:flex; }

      details.card.photos,
      details.card.templates{ overflow:hidden; }
      details.card.photos:not([open]) .body,
      details.card.templates:not([open]) .body{ display:none; }

      .thumbs{
        display:flex; gap:8px; overflow:auto; max-height:none; padding-bottom:2px;
      }
      .thumb{ flex:0 0 120px; }
    }

    .controls-scroll::-webkit-scrollbar{ width:10px; height:10px; }
    .controls-scroll::-webkit-scrollbar-thumb{ background:#2a3955; border-radius:8px; }
    .controls-scroll::-webkit-scrollbar-track{ background:#0b1020; }
  </style>
</head>
<body>
  <header id="appHeader">
    <div class="head-left">
      <h1>Watermark Studio</h1>
      <div class="sub">Drag & drop your logo and photos • Add text • Position, tilt, and save templates</div>
    </div>

    <div class="head-actions">
      <button class="btn" id="btn-export">Download Current</button>
      <button class="btn primary" id="btn-export-all">Process All as ZIP</button>
      <button class="btn warn" id="btn-remove-current" title="Remove current photo from list">Remove Current</button>

      <!-- Save-anywhere controls -->
      <button class="btn accent" id="btn-choose-dir" title="Pick a folder to save images into">Choose Save Folder</button>
      <button class="btn" id="btn-save-current-to-dir" disabled>Save Current to Folder</button>
      <button class="btn" id="btn-save-all-to-dir" disabled>Process All to Folder</button>
      <span class="note" id="dir-note"></span>
    </div>

    <div class="mobile-tabs" role="tablist" aria-label="View switch">
      <button class="tab active" id="tab-preview" aria-selected="true">Preview</button>
      <button class="tab" id="tab-controls" aria-selected="false">Controls</button>
    </div>
  </header>

  <div class="wrap">
    <!-- LEFT / PANEL: CONTROLS -->
    <div class="col controls-panel pane" id="pane-controls" aria-labelledby="tab-controls">
      <div class="controls-scroll">
        <div class="card">
          <h2>Watermark (Logo)</h2>
          <div class="body">
            <div id="logo-drop" class="drop" tabindex="0">
              <div><strong>Drop logo here</strong> or tap to browse</div>
              <div class="muted">PNG with transparency recommended</div>
              <input id="logo-input" type="file" accept="image/*" style="display:none" />
            </div>
            <div class="controls">
              <div class="row">
                <label>Scale (% of photo width)</label>
                <input id="scale" type="range" min="1" max="100" value="25" />
              </div>
              <div class="row">
                <label>Opacity</label>
                <input id="opacity" type="range" min="1" max="100" value="70" />
              </div>
              <div class="row">
                <label>Anchor</label>
                <select id="anchor">
                  <option value="top-left">Top Left</option>
                  <option value="top-center">Top Center</option>
                  <option value="top-right">Top Right</option>
                  <option value="center-left">Center Left</option>
                  <option value="center">Center</option>
                  <option value="center-right">Center Right</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="bottom-center" selected>Bottom Center</option>
                  <option value="bottom-right">Bottom Right</option>
                </select>
              </div>
              <div class="row">
                <label>Offset X (px)</label>
                <input id="offsetX" type="number" value="0" />
              </div>
              <div class="row">
                <label>Offset Y (px)</label>
                <input id="offsetY" type="number" value="-20" />
              </div>
              <div class="row">
                <label>Allow drag on preview</label>
                <input id="dragToggle" type="checkbox" checked />
              </div>
            </div>
          </div>
        </div>

        <div class="card">
          <h2>Text Watermark</h2>
          <div class="body">
            <div class="controls">
              <div class="row">
                <label>Text</label>
                <input id="txt-text" type="text" placeholder="Type your watermark text" />
              </div>
              <div class="row">
                <label>Font family</label>
                <select id="txt-font">
                  <option value="Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial">Sans</option>
                  <option value="Georgia, 'Times New Roman', Times, serif">Serif</option>
                  <option value="'Courier New', Courier, monospace">Mono</option>
                </select>
              </div>
              <div class="row">
                <label>Size (px)</label>
                <input id="txt-size" type="number" value="48" min="6" />
              </div>
              <div class="row">
                <label>Color</label>
                <input id="txt-color" type="color" value="#ffffff" />
              </div>
              <div class="row">
                <label>Opacity</label>
                <input id="txt-opacity" type="range" min="1" max="100" value="70" />
              </div>
              <div class="row">
                <label>Tilt (°)</label>
                <input id="txt-rot" type="range" min="-180" max="180" value="0" />
              </div>

              <div class="row">
                <label>Text Anchor</label>
                <select id="txt-anchor">
                  <option value="top-left">Top Left</option>
                  <option value="top-center">Top Center</option>
                  <option value="top-right">Top Right</option>
                  <option value="center-left">Center Left</option>
                  <option value="center">Center</option>
                  <option value="center-right">Center Right</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="bottom-center">Bottom Center</option>
                  <option value="bottom-right">Bottom Right</option>
                </select>
              </div>
              <div class="row">
                <label>Text Offset X (px)</label>
                <input id="txt-offx" type="number" value="0" />
              </div>
              <div class="row">
                <label>Text Offset Y (px)</label>
                <input id="txt-offy" type="number" value="0" />
              </div>

              <div style="display:flex; gap:8px; flex-wrap:wrap;">
                <button class="btn" id="btn-reset-tilt">Reset Tilt</button>
                <label style="display:flex; align-items:center; gap:8px;">
                  <span class="muted">Enable text drag</span>
                  <input id="txt-drag-toggle" type="checkbox" checked />
                </label>
              </div>
            </div>
          </div>
        </div>

        <details class="card photos" open>
          <summary>Photos</summary>
          <div class="body">
            <div id="photo-drop" class="drop" tabindex="0">
              <div><strong>Drop photos here</strong> or tap to browse</div>
              <div class="muted">JPG/PNG; you can add multiple</div>
              <input id="photo-input" type="file" accept="image/*" multiple style="display:none" />
            </div>
            <div class="thumbs" id="photo-thumbs"></div>
          </div>
        </details>

        <details class="card templates">
          <summary>Templates</summary>
          <div class="body">
            <div class="row" style="grid-template-columns: 1fr auto;">
              <input type="text" id="tpl-name" placeholder="Template name" />
              <button class="btn" id="btn-save-tpl">Save</button>
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <button class="btn" id="btn-export-tpl" title="Save template to a .json file">Export Template</button>
              <input id="tpl-import-input" type="file" accept="application/json" style="display:none" />
              <button class="btn" id="btn-import-tpl" title="Load template from a .json file">Import Template</button>
              <button class="btn warn" id="btn-clear-templates" title="Delete ALL saved templates">Clear All</button>
            </div>
            <div id="tpl-list" class="controls"></div>
          </div>
        </details>
      </div>
    </div>

    <!-- RIGHT / PANE: PREVIEW -->
    <div class="col pane active" id="pane-preview" aria-labelledby="tab-preview">
      <div class="card" style="min-height:0; height:100%;">
        <h2>Preview</h2>
        <div class="body" style="height: calc(100% - 44px);">
          <div class="preview" id="preview">
            <!-- Zoom UI overlay (no slider) -->
            <div class="zoombar" id="zoombar">
              <button class="zbtn" id="zoom-out" title="Zoom out (Ctrl/⌘ + scroll)">−</button>
              <button class="zbtn" id="zoom-in"  title="Zoom in (Ctrl/⌘ + scroll)">+</button>
              <button class="zbtn" id="zoom-fit" title="Fit to screen">Fit</button>
              <button class="zbtn" id="zoom-100" title="Actual size">100%</button>
            </div>
            <div class="zoom-readout" id="zoom-readout">100%</div>

            <canvas id="canvas"></canvas>
          </div>

          <div class="row">
            <div class="muted">Format</div>
            <select id="format">
              <option value="image/png">PNG</option>
              <option value="image/jpeg">JPEG</option>
            </select>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Optional zipping for batch export -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <script>
    /* Header height calibration */
    (function calibrateHeader() {
      const header = document.getElementById('appHeader');
      const set = () => {
        const h = Math.round(header.getBoundingClientRect().height);
        document.documentElement.style.setProperty('--headH', h + 'px');
      };
      set();
      new ResizeObserver(set).observe(header);
      window.addEventListener('orientationchange', set);
      window.addEventListener('resize', set);
    })();

    /* Mobile tab switch */
    (function tabs(){
      const tabPrev = document.getElementById('tab-preview');
      const tabCtrl = document.getElementById('tab-controls');
      const panePrev = document.getElementById('pane-preview');
      const paneCtrl = document.getElementById('pane-controls');

      function activate(which){
        const isPrev = which === 'preview';
        tabPrev.classList.toggle('active', isPrev);
        tabPrev.setAttribute('aria-selected', isPrev);
        panePrev.classList.toggle('active', isPrev);
        tabCtrl.classList.toggle('active', !isPrev);
        tabCtrl.setAttribute('aria-selected', !isPrev);
        paneCtrl.classList.toggle('active', !isPrev);
      }

      tabPrev?.addEventListener('click', () => activate('preview'));
      tabCtrl?.addEventListener('click', () => activate('controls'));

      const mm = window.matchMedia('(max-width: 980px)');
      const handle = () => {
        if (mm.matches) activate('preview');
        else { panePrev.classList.add('active'); paneCtrl.classList.add('active'); }
      };
      handle();
      mm.addEventListener('change', handle);
    })();

    // --- State ---
    const state = {
      logoImg: null,
      photos: [], // {name, img}
      currentIndex: -1,
      settings: { scalePct: 25, opacity: 0.7, anchor: 'bottom-center', offsetX: 0, offsetY: -20 },
      drag:   { enabled: true, active: false, dx:0, dy:0, id:null }, // logo
      text:   {
        value: '', fontFamily: "Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
        sizePx: 48, color: '#ffffff', opacity: 0.7, rotDeg: 0,
        anchor: 'center', offsetX: 0, offsetY: 0,
        dragEnabled: true, drag: { active:false, dx:0, dy:0, id:null }
      },
      outDir: null, outDirName: '',
      zoom: 1, zoomMode: 'fit' // 'fit' | 'manual'
    };

    // --- Elements ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
    const previewEl = document.getElementById('preview');
    const zoomReadout = document.getElementById('zoom-readout');

    // Inputs
    const logoDrop = document.getElementById('logo-drop');
    const logoInput = document.getElementById('logo-input');
    const photoDrop = document.getElementById('photo-drop');
    const photoInput = document.getElementById('photo-input');
    const thumbs = document.getElementById('photo-thumbs');

    const scaleEl = document.getElementById('scale');
    const opacityEl = document.getElementById('opacity');
    const anchorEl = document.getElementById('anchor');
    const offsetXEl = document.getElementById('offsetX');
    const offsetYEl = document.getElementById('offsetY');
    const dragToggle = document.getElementById('dragToggle');
    const formatEl = document.getElementById('format');

    const exportBtn = document.getElementById('btn-export');
    const exportAllBtn = document.getElementById('btn-export-all');
    const removeCurrentBtn = document.getElementById('btn-remove-current');

    // Save-anywhere
    const chooseDirBtn = document.getElementById('btn-choose-dir');
    const saveCurrentToDirBtn = document.getElementById('btn-save-current-to-dir');
    const saveAllToDirBtn = document.getElementById('btn-save-all-to-dir');
    const dirNote = document.getElementById('dir-note');

    // Text
    const txtTextEl = document.getElementById('txt-text');
    const txtFontEl = document.getElementById('txt-font');
    const txtSizeEl = document.getElementById('txt-size');
    const txtColorEl = document.getElementById('txt-color');
    const txtOpacityEl = document.getElementById('txt-opacity');
    const txtRotEl = document.getElementById('txt-rot');
    const txtDragToggle = document.getElementById('txt-drag-toggle');
    const resetTiltBtn = document.getElementById('btn-reset-tilt');
    const txtAnchorEl = document.getElementById('txt-anchor');
    const txtOffXEl  = document.getElementById('txt-offx');
    const txtOffYEl  = document.getElementById('txt-offy');

    // Zoom buttons
    const zIn = document.getElementById('zoom-in');
    const zOut = document.getElementById('zoom-out');
    const zFit = document.getElementById('zoom-fit');
    const z100 = document.getElementById('zoom-100');

    // --- Helpers ---
    function readAsImage(file){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => {
          const img = new Image();
          img.onload = () => resolve({ img, name:file.name });
          img.onerror = reject;
          img.src = fr.result;
        };
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });
    }

    /* rAF drawing for smooth pointer interactions */
    let rafPending = false;
    function scheduleDraw(){
      if (rafPending) return;
      rafPending = true;
      requestAnimationFrame(() => { rafPending = false; draw(); });
    }

    /* Canvas placement */
    function logoDims(){
      if (!state.logoImg || !state.photos[state.currentIndex]) return { w:0, h:0 };
      const targetW = canvas.width * (state.settings.scalePct / 100);
      const aspect = state.logoImg.naturalWidth / state.logoImg.naturalHeight;
      return { w: targetW, h: targetW / aspect };
    }
    function logoBasePos(){
      const { w, h } = logoDims();
      const cx = canvas.width/2, cy = canvas.height/2;
      switch (state.settings.anchor){
        case 'top-left': return { x:0, y:0 };
        case 'top-center': return { x:cx - w/2, y:0 };
        case 'top-right': return { x:canvas.width - w, y:0 };
        case 'center-left': return { x:0, y:cy - h/2 };
        case 'center': return { x:cx - w/2, y:cy - h/2 };
        case 'center-right': return { x:canvas.width - w, y:cy - h/2 };
        case 'bottom-left': return { x:0, y:canvas.height - h };
        case 'bottom-center': return { x:cx - w/2, y:canvas.height - h };
        case 'bottom-right': return { x:canvas.width - w, y:canvas.height - h };
      }
      return { x:0, y:0 };
    }
    function logoPos(){
      const base = logoBasePos();
      return { x: base.x + Number(state.settings.offsetX||0), y: base.y + Number(state.settings.offsetY||0) };
    }

    function measureTextSize(){
      const tctx = document.createElement('canvas').getContext('2d');
      tctx.font = `${state.text.sizePx}px ${state.text.fontFamily}`;
      const w = Math.ceil(tctx.measureText(state.text.value || '').width);
      const h = state.text.sizePx;
      return { w, h };
    }
    function textBasePos(){
      const { w, h } = measureTextSize();
      const cx = canvas.width/2, cy = canvas.height/2;
      switch (state.text.anchor){
        case 'top-left': return { x:0, y:0 };
        case 'top-center': return { x:cx - w/2, y:0 };
        case 'top-right': return { x:canvas.width - w, y:0 };
        case 'center-left': return { x:0, y:cy - h/2 };
        case 'center': return { x:cx - w/2, y:cy - h/2 };
        case 'center-right': return { x:canvas.width - w, y:cy - h/2 };
        case 'bottom-left': return { x:0, y:canvas.height - h };
        case 'bottom-center': return { x:cx - w/2, y:canvas.height - h };
        case 'bottom-right': return { x:canvas.width - w, y:canvas.height - h };
      }
      return { x:0, y:0 };
    }
    function textPos(){
      const base = textBasePos();
      return { x: base.x + Number(state.text.offsetX||0), y: base.y + Number(state.text.offsetY||0) };
    }

    /* Zoom handling */
    function computeFitZoom(){
      if (!canvas.width || !canvas.height) return 1;
      const pad = 16; // align with .preview padding and borders
      const availW = Math.max(100, previewEl.clientWidth - pad);
      const availH = Math.max(100, previewEl.clientHeight - pad);
      return Math.min(availW / canvas.width, availH / canvas.height);
    }
    function applyZoom(){
      if (state.zoomMode === 'fit') state.zoom = computeFitZoom();
      canvas.style.transform = `scale(${state.zoom})`;
      zoomReadout.textContent = `${Math.round(state.zoom*100)}%`;
    }
    function setZoom(z, mode='manual'){
      state.zoom = Math.min(8, Math.max(0.05, z));
      state.zoomMode = mode;
      applyZoom();
    }
    function zoomStep(dir){ // dir: +1 or -1
      const step = dir > 0 ? 1.1 : 1/1.1;
      setZoom(state.zoom * step, 'manual');
    }
    new ResizeObserver(() => { if (state.zoomMode==='fit') applyZoom(); }).observe(previewEl);

    /* Drawing */
    function draw(){
      const photo = state.photos[state.currentIndex];
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (!photo) { applyZoom(); return; }

      canvas.width = photo.img.naturalWidth;
      canvas.height = photo.img.naturalHeight;

      ctx.drawImage(photo.img, 0, 0);

      if (state.logoImg){
        const { w, h } = logoDims();
        const p = logoPos();
        ctx.globalAlpha = state.settings.opacity;
        ctx.drawImage(state.logoImg, p.x, p.y, w, h);
        ctx.globalAlpha = 1;
      }

      if (state.text.value){
        const p = textPos();
        const t = state.text;
        ctx.save();
        ctx.globalAlpha = t.opacity;
        ctx.font = `${t.sizePx}px ${t.fontFamily}`;
        ctx.fillStyle = t.color;
        ctx.textBaseline = 'top';
        ctx.translate(p.x, p.y);
        ctx.rotate((t.rotDeg || 0) * Math.PI / 180);
        ctx.fillText(t.value, 0, 0);
        ctx.restore();
      }

      applyZoom();
    }

    function setCurrent(index){ state.currentIndex = index; scheduleDraw(); }

    function refreshThumbs(){
      thumbs.innerHTML = '';
      state.photos.forEach((p,i) => {
        const div = document.createElement('div');
        div.className = 'thumb';
        div.innerHTML = `<img alt="thumb"/><div class="name">${p.name}</div><div class="pick">Use</div><div class="trash">Del</div>`;
        div.querySelector('img').src = p.img.src;
        div.querySelector('.pick').onclick = () => setCurrent(i);
        div.querySelector('.trash').onclick = () => removePhotoAt(i);
        thumbs.appendChild(div);
      });
      if (state.currentIndex === -1 && state.photos.length) setCurrent(0);
    }

    function removePhotoAt(i){
      if (i < 0 || i >= state.photos.length) return;
      state.photos.splice(i,1);
      if (!state.photos.length){
        state.currentIndex = -1; ctx.clearRect(0,0,canvas.width,canvas.height);
      } else if (state.currentIndex >= state.photos.length){
        state.currentIndex = state.photos.length - 1;
      }
      refreshThumbs(); scheduleDraw();
    }

    function bindDropzone(zoneEl, inputEl, onFiles){
      const openPicker = () => inputEl.click();
      zoneEl.addEventListener('click', openPicker);
      zoneEl.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') openPicker(); });
      zoneEl.addEventListener('dragover', e => { e.preventDefault(); zoneEl.classList.add('dragover'); });
      zoneEl.addEventListener('dragleave', () => zoneEl.classList.remove('dragover'));
      zoneEl.addEventListener('drop', async e => {
        e.preventDefault(); zoneEl.classList.remove('dragover');
        const files = [...e.dataTransfer.files].filter(f => f.type.startsWith('image/'));
        if (files.length) onFiles(files);
      });
      inputEl.addEventListener('change', () => {
        const files = [...inputEl.files];
        if (files.length) onFiles(files);
        inputEl.value='';
      });
    }

    bindDropzone(logoDrop, logoInput, async files => {
      const f = files[0];
      const { img } = await readAsImage(f);
      state.logoImg = img; scheduleDraw();
    });

    bindDropzone(photoDrop, photoInput, async files => {
      for (const f of files){
        const { img, name } = await readAsImage(f);
        state.photos.push({ img, name });
      }
      refreshThumbs(); scheduleDraw();
    });

    // Controls — logo
    scaleEl.addEventListener('input', () => { state.settings.scalePct = Number(scaleEl.value); scheduleDraw(); });
    opacityEl.addEventListener('input', () => { state.settings.opacity = Number(opacityEl.value)/100; scheduleDraw(); });
    anchorEl.addEventListener('change', () => { state.settings.anchor = anchorEl.value; scheduleDraw(); });
    offsetXEl.addEventListener('input', () => { state.settings.offsetX = Number(offsetXEl.value||0); scheduleDraw(); });
    offsetYEl.addEventListener('input', () => { state.settings.offsetY = Number(offsetYEl.value||0); scheduleDraw(); });
    dragToggle.addEventListener('change', () => { state.drag.enabled = dragToggle.checked; });

    // Controls — text
    txtTextEl.addEventListener('input', () => { state.text.value = txtTextEl.value; scheduleDraw(); });
    txtFontEl.addEventListener('change', () => { state.text.fontFamily = txtFontEl.value; scheduleDraw(); });
    txtSizeEl.addEventListener('input', () => { state.text.sizePx = Math.max(6, Number(txtSizeEl.value||0)); scheduleDraw(); });
    txtColorEl.addEventListener('input', () => { state.text.color = txtColorEl.value; scheduleDraw(); });
    txtOpacityEl.addEventListener('input', () => { state.text.opacity = Number(txtOpacityEl.value)/100; scheduleDraw(); });
    txtRotEl.addEventListener('input', () => { state.text.rotDeg = Number(txtRotEl.value); scheduleDraw(); });

    txtAnchorEl.addEventListener('change', () => { state.text.anchor = txtAnchorEl.value; scheduleDraw(); });
    txtOffXEl.addEventListener('input', () => { state.text.offsetX = Number(txtOffXEl.value||0); scheduleDraw(); });
    txtOffYEl.addEventListener('input', () => { state.text.offsetY = Number(txtOffYEl.value||0); scheduleDraw(); });

    txtDragToggle.addEventListener('change', () => { state.text.dragEnabled = txtDragToggle.checked; });
    resetTiltBtn.addEventListener('click', () => { state.text.rotDeg = 0; txtRotEl.value = 0; scheduleDraw(); });

    removeCurrentBtn.addEventListener('click', () => { if (state.currentIndex !== -1) removePhotoAt(state.currentIndex); });

    /* Pointer -> canvas coords (zoom-aware) */
    function getPointerCanvasXY(e){
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      const x = (e.clientX - rect.left) * scaleX;
      const y = (e.clientY - rect.top)  * scaleY;
      return { x, y };
    }

    function measureTextRectForHit(){
      if (!state.text.value) return null;
      const { w, h } = measureTextSize();
      const p = textPos();
      const rad = (state.text.rotDeg||0) * Math.PI/180;
      const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
      const bw = Math.ceil(w * cos + h * sin);
      const bh = Math.ceil(w * sin + h * cos);
      return { x:p.x, y:p.y, w:bw, h:bh };
    }
    function pointInRect(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

    let dragTarget = null; // 'text' | 'logo'
    let lastTapTime = 0;

    // Smooth, mobile-friendly dragging (pointer capture + rAF)
    canvas.addEventListener('pointerdown', (e) => {
      if (state.currentIndex === -1) return;
      const now = Date.now();
      if (now - lastTapTime < 300){ zoomStep(+1); lastTapTime = 0; return; } // double-tap zoom in
      lastTapTime = now;

      e.preventDefault();
      canvas.setPointerCapture(e.pointerId);

      const { x, y } = getPointerCanvasXY(e);

      // Text first
      const tr = measureTextRectForHit();
      if (state.text.dragEnabled && tr && pointInRect(x,y,tr)){
        dragTarget = 'text';
        state.text.drag.active = true;
        state.text.drag.id = e.pointerId;
        const p = textPos();
        state.text.drag.dx = x - p.x;
        state.text.drag.dy = y - p.y;
        return;
      }

      // Logo next
      if (state.drag.enabled && state.logoImg){
        const { w, h } = logoDims();
        const p = logoPos();
        const r = { x:p.x, y:p.y, w, h };
        if (pointInRect(x,y,r)){
          dragTarget = 'logo';
          state.drag.active = true;
          state.drag.id = e.pointerId;
          state.drag.dx = x - p.x;
          state.drag.dy = y - p.y;
        }
      }
    }, { passive:false });

    canvas.addEventListener('pointermove', (e) => {
      if (e.pointerId !== state.drag.id && e.pointerId !== state.text.drag.id) return;
      if (dragTarget === 'text' && state.text.drag.active){
        e.preventDefault();
        const { x, y } = getPointerCanvasXY(e);
        const newX = Math.round(x - state.text.drag.dx);
        const newY = Math.round(y - state.text.drag.dy);
        const base = textBasePos();
        state.text.offsetX = newX - base.x;
        state.text.offsetY = newY - base.y;
        txtOffXEl.value = state.text.offsetX;
        txtOffYEl.value = state.text.offsetY;
        scheduleDraw();
      } else if (dragTarget === 'logo' && state.drag.active){
        e.preventDefault();
        const { x, y } = getPointerCanvasXY(e);
        const newX = Math.round(x - state.drag.dx);
        const newY = Math.round(y - state.drag.dy);
        const base = logoBasePos();
        state.settings.offsetX = newX - base.x;
        state.settings.offsetY = newY - base.y;
        offsetXEl.value = state.settings.offsetX;
        offsetYEl.value = state.settings.offsetY;
        scheduleDraw();
      }
    }, { passive:false });

    function endDrag(){
      dragTarget = null;
      state.drag.active = false; state.drag.id = null;
      state.text.drag.active = false; state.text.drag.id = null;
    }
    canvas.addEventListener('pointerup',   endDrag, { passive:true });
    canvas.addEventListener('pointercancel', endDrag, { passive:true });
    canvas.addEventListener('lostpointercapture', endDrag, { passive:true });

    /* Scroll-to-zoom: Ctrl/⌘ + wheel */
    previewEl.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey){
        e.preventDefault();
        if (e.deltaY < 0) zoomStep(+1); else zoomStep(-1);
      }
    }, { passive:false });

    /* Zoom buttons */
    zIn.addEventListener('click',  () => zoomStep(+1));
    zOut.addEventListener('click', () => zoomStep(-1));
    zFit.addEventListener('click', () => setZoom(computeFitZoom(), 'fit'));
    z100.addEventListener('click', () => setZoom(1, 'manual'));

    /* Downloads */
    function downloadCurrent(){
      const photo = state.photos[state.currentIndex];
      if (!photo) return alert('Add a photo first.');
      const mime = formatEl.value;
      const name = photo.name.replace(/\.[^.]+$/, '');
      canvas.toBlob((blob) => {
        if (!blob) return;
        const ext = mime === 'image/png' ? 'png' : 'jpg';
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = `${name}_watermarked.${ext}`;
        a.click();
        URL.revokeObjectURL(a.href);
      }, mime, mime === 'image/jpeg' ? 0.92 : undefined);
    }

    async function processAllZip(){
      if (!state.photos.length) return alert('Add some photos first.');
      if (typeof JSZip === 'undefined'){ alert('JSZip not loaded. Try again or download individually.'); return; }
      const zip = new JSZip();
      const mime = formatEl.value;
      for (let i=0;i<state.photos.length;i++){
        setCurrent(i);
        await new Promise(r => requestAnimationFrame(r));
        const blob = await new Promise(res => canvas.toBlob(res, mime, mime === 'image/jpeg' ? 0.92 : undefined));
        const base = state.photos[i].name.replace(/\.[^.]+$/, '');
        const name = `${base}_watermarked${mime==='image/png'?'.png':'.jpg'}`;
        zip.file(name, blob);
      }
      const out = await zip.generateAsync({ type:'blob' });
      if ('showSaveFilePicker' in window){
        try{
          const handle = await window.showSaveFilePicker({
            suggestedName:'watermarked_photos.zip',
            types:[{ description:'ZIP Archive', accept:{'application/zip':['.zip']} }]
          });
          const writable = await handle.createWritable();
          await writable.write(out); await writable.close();
          return;
        }catch(e){ /* cancelled */ }
      }
      saveAs(out, 'watermarked_photos.zip');
    }

    exportBtn.addEventListener('click', downloadCurrent);
    exportAllBtn.addEventListener('click', processAllZip);

    /* Save to chosen folder (no overwrite) */
    function fsSupported(){ return 'showDirectoryPicker' in window; }
    function updateDirUI(){
      const on = !!state.outDir;
      saveCurrentToDirBtn.disabled = !on;
      saveAllToDirBtn.disabled = !on;
      dirNote.textContent = on ? `Saving to: ${state.outDirName}` :
        (fsSupported() ? 'Pick a folder to save images there.' : 'Folder saving not supported in this browser.');
      chooseDirBtn.style.display = fsSupported() ? '' : 'none';
      saveCurrentToDirBtn.style.display = fsSupported() ? '' : 'none';
      saveAllToDirBtn.style.display  = fsSupported() ? '' : 'none';
    }
    async function ensureDirPermission(){
      if (!state.outDir) return false;
      if (!state.outDir.queryPermission) return true;
      const q = await state.outDir.queryPermission({ mode:'readwrite' });
      if (q === 'granted') return true;
      if (q === 'prompt'){
        const r = await state.outDir.requestPermission({ mode:'readwrite' });
        return r === 'granted';
      }
      return false;
    }
    chooseDirBtn.addEventListener('click', async () => {
      if (!fsSupported()){ alert('Your browser does not support choosing a save folder. Try Chrome/Edge.'); return; }
      try{
        const dir = await window.showDirectoryPicker({ mode:'readwrite' });
        state.outDir = dir;
        state.outDirName = dir.name || 'Selected Folder';
        const ok = await ensureDirPermission();
        if (!ok){ alert('Permission denied for that folder.'); state.outDir = null; }
      }catch(e){ /* cancelled */ }
      updateDirUI();
    });

    function splitName(filename){
      const idx = filename.lastIndexOf('.');
      if (idx > 0) return { base: filename.slice(0, idx), ext: filename.slice(idx) };
      return { base: filename, ext: '' };
    }
    async function fileExists(dir, name){
      try{ await dir.getFileHandle(name, { create:false }); return true; }
      catch(e){ return false; }
    }
    async function uniqueName(dir, desired){
      if (!(await fileExists(dir, desired))) return desired;
      const { base, ext } = splitName(desired);
      for (let i=1;i<10000;i++){
        const cand = `${base} (${i})${ext}`;
        if (!(await fileExists(dir, cand))) return cand;
      }
      return `${base} (${Date.now()})${ext}`;
    }
    async function saveBlobToDir(filename, blob){
      if (!await ensureDirPermission()){ alert('No permission to write to the chosen folder.'); return; }
      const finalName = await uniqueName(state.outDir, filename);
      const fileHandle = await state.outDir.getFileHandle(finalName, { create:true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob); await writable.close();
      return finalName;
    }

    async function saveCurrentToDir(){
      const photo = state.photos[state.currentIndex];
      if (!photo) return alert('Add a photo first.');
      const mime = formatEl.value;
      const base = photo.name.replace(/\.[^.]+$/, '');
      const ext = mime === 'image/png' ? '.png' : '.jpg';
      const fileName = `${base}_watermarked${ext}`;
      const blob = await new Promise(res => canvas.toBlob(res, mime, mime === 'image/jpeg' ? 0.92 : undefined));
      const savedAs = await saveBlobToDir(fileName, blob);
      if (savedAs) dirNote.textContent = `Saved ${savedAs} to: ${state.outDirName}`;
    }
    async function saveAllToDir(){
      if (!state.photos.length) return alert('Add some photos first.');
      const mime = formatEl.value;
      for (let i=0;i<state.photos.length;i++){
        setCurrent(i);
        await new Promise(r => requestAnimationFrame(r));
        const base = state.photos[i].name.replace(/\.[^.]+$/, '');
        const ext = mime === 'image/png' ? '.png' : '.jpg';
        const fileName = `${base}_watermarked${ext}`;
        const blob = await new Promise(res => canvas.toBlob(res, mime, mime === 'image/jpeg' ? 0.92 : undefined));
        await saveBlobToDir(fileName, blob);
      }
      dirNote.textContent = `Saved ${state.photos.length} file(s) to: ${state.outDirName}`;
    }
    saveCurrentToDirBtn.addEventListener('click', saveCurrentToDir);
    saveAllToDirBtn.addEventListener('click', saveAllToDir);
    updateDirUI();

    /* Templates (LocalStorage + Import/Export) */
    const LS_KEY = 'wm_templates_v3';
    function getTemplates(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)) || []; } catch{ return []; } }
    function setTemplates(list){ localStorage.setItem(LS_KEY, JSON.stringify(list)); }
    function serializeTemplate(name){
      let logoDataUrl = null;
      if (state.logoImg){
        const tmp = document.createElement('canvas');
        tmp.width = state.logoImg.naturalWidth; tmp.height = state.logoImg.naturalHeight;
        tmp.getContext('2d').drawImage(state.logoImg, 0, 0);
        logoDataUrl = tmp.toDataURL('image/png');
      }
      return { name, settings:{...state.settings}, logo:{ dataUrl:logoDataUrl }, text:{...state.text}, createdAt:Date.now(), version:3 };
    }
    function saveTemplate(name){
      if (!name){ alert('Enter a template name.'); return; }
      const tpl = serializeTemplate(name);
      const list = getTemplates().filter(t => t.name !== name);
      list.unshift(tpl); setTemplates(list); renderTplList(); alert('Template saved.');
    }
    function applyTemplate(tpl){
      if (tpl.logo?.dataUrl){
        const img = new Image();
        img.onload = () => { state.logoImg = img; restoreStateFromTpl(tpl); };
        img.src = tpl.logo.dataUrl;
      } else {
        state.logoImg = null; restoreStateFromTpl(tpl);
      }
    }
    function restoreStateFromTpl(tpl){
      state.settings = { ...state.settings, ...tpl.settings };
      if (tpl.text) state.text = { ...state.text, ...tpl.text };
      syncControls(); scheduleDraw();
    }
    function deleteTemplate(name){
      if (!confirm(`Delete template "${name}"?`)) return;
      const list = getTemplates().filter(t => t.name !== name);
      setTemplates(list); renderTplList();
    }
    function renderTplList(){
      const list = getTemplates();
      const tplListEl = document.getElementById('tpl-list');
      tplListEl.innerHTML = '';
      if (!list.length){
        const p = document.createElement('div'); p.className='muted'; p.textContent='No templates yet.';
        tplListEl.appendChild(p); return;
      }
      list.forEach(t => {
        const row = document.createElement('div');
        row.className = 'template-row';
        row.innerHTML = `
          <div>
            <div style="font-size:12px; font-weight:700;">${t.name}</div>
            <div class="muted" style="font-size:10px;">Scale ${t.settings.scalePct}% · Logo ${Math.round(t.settings.opacity*100)}% · ${t.settings.anchor}${t.text?.value ? ' · Text ✓' : ''}</div>
          </div>
          <button class="btn" data-act="load">Load</button>
          <button class="btn" data-act="rename">Rename</button>
          <button class="btn" data-act="export">Export</button>
          <button class="btn warn" data-act="delete">Delete</button>
        `;
        row.querySelector('[data-act="load"]').onclick = () => applyTemplate(t);
        row.querySelector('[data-act="delete"]').onclick = () => deleteTemplate(t.name);
        row.querySelector('[data-act="rename"]').onclick = () => {
          const nn = prompt('New name', t.name); if (!nn) return;
          const list2 = getTemplates(); const idx = list2.findIndex(x => x.name === t.name);
          if (idx >= 0){ list2[idx].name = nn; setTemplates(list2); renderTplList(); }
        };
        row.querySelector('[data-act="export"]').onclick = () => {
          const blob = new Blob([JSON.stringify(t, null, 2)], { type:'application/json' });
          saveAs(blob, `${t.name || 'template'}.json`);
        };
        tplListEl.appendChild(row);
      });
    }

    document.getElementById('btn-save-tpl').addEventListener('click', () => saveTemplate(document.getElementById('tpl-name').value.trim()));
    document.getElementById('btn-export-tpl').addEventListener('click', () => {
      const name = document.getElementById('tpl-name').value.trim() || 'template';
      const blob = new Blob([JSON.stringify(serializeTemplate(name), null, 2)], { type:'application/json' });
      saveAs(blob, `${name}.json`);
    });
    document.getElementById('btn-import-tpl').addEventListener('click', () => document.getElementById('tpl-import-input').click());
    document.getElementById('tpl-import-input').addEventListener('change', () => {
      const f = document.getElementById('tpl-import-input').files[0]; if (!f) return;
      const fr = new FileReader();
      fr.onload = () => {
        try{
          const tpl = JSON.parse(fr.result);
          const list = getTemplates().filter(t => t.name !== tpl.name);
          list.unshift(tpl); setTemplates(list); renderTplList(); applyTemplate(tpl);
        }catch(e){ alert('Failed to import template: ' + e.message); }
      };
      fr.readAsText(f); document.getElementById('tpl-import-input').value='';
    });
    document.getElementById('btn-clear-templates').addEventListener('click', () => {
      if (!getTemplates().length){ alert('No templates saved.'); return; }
      if (confirm('Delete ALL saved templates? This cannot be undone.')){ setTemplates([]); renderTplList(); }
    });

    function syncControls(){
      scaleEl.value = state.settings.scalePct;
      opacityEl.value = Math.round(state.settings.opacity * 100);
      anchorEl.value = state.settings.anchor;
      offsetXEl.value = state.settings.offsetX;
      offsetYEl.value = state.settings.offsetY;
      dragToggle.checked = state.drag.enabled;

      txtTextEl.value = state.text.value;
      txtFontEl.value = state.text.fontFamily;
      txtSizeEl.value = state.text.sizePx;
      txtColorEl.value = state.text.color;
      txtOpacityEl.value = Math.round(state.text.opacity * 100);
      txtRotEl.value = state.text.rotDeg;
      txtDragToggle.checked = state.text.dragEnabled;
      txtAnchorEl.value = state.text.anchor;
      txtOffXEl.value = state.text.offsetX;
      txtOffYEl.value = state.text.offsetY;
    }

    // Init
    renderTplList();
    syncControls();
    setZoom(1, 'fit'); // start in "Fit" mode
  </script>
</body>
</html>
