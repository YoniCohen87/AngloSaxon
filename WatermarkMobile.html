<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Watermark Studio — Thumbs + Expandable Controls + Anchor Snap</title>
  <style>
    :root{
      --bg:#0b0d12; --panel:#131722; --muted:#8b9bb3; --text:#e6edf6;
      --accent:#7aa2f7; --border:#273042; --headH:66px;
      --safe-top: env(safe-area-inset-top, 0px);
      --safe-bottom: env(safe-area-inset-bottom, 0px);
    }
    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; }
    html, body { overflow-x: hidden; }
    body{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: linear-gradient(180deg,#0b0d12 0%,#101521 100%);
      color:var(--text);
      height:100svh;
      overflow:hidden;
    }
    @supports not (height:100svh){ body{ height:100vh; } }

    header{
      padding: calc(12px + var(--safe-top)) 16px 12px;
      border-bottom:1px solid var(--border);
      background:rgba(19,23,34,0.8);
      position:sticky; top:0; backdrop-filter: blur(6px);
      display:grid; grid-template-columns: 1fr auto; gap:12px; align-items:center;
      z-index:10; min-width:0; max-width:100%;
    }
    header h1{ font-size:18px; margin:0; font-weight:700; letter-spacing:.2px; }
    header .sub{ color:var(--muted); font-size:12px; margin-top:2px; }
    .head-left{ display:flex; flex-direction:column; gap:2px; min-width:0; }

    /* Actions area reduced by ~15% */
    .head-actions{
      display:flex; gap:6px; align-items:center;
      overflow-x:auto; -webkit-overflow-scrolling:touch; padding-bottom:0;
      min-width:0; max-width:100%;
    }
    .btn{
      background:#1a2440; color:#fff; border:1px solid var(--border);
      padding:10px 12px; border-radius:12px; cursor:pointer; transition:.15s ease;
      font-weight:600; white-space:nowrap; flex:0 0 auto; min-height:44px;
    }
    /* 15% smaller buttons in actions area */
    .head-actions .btn{
      padding: 8.5px 10px;
      min-height: 38px;
      font-size: .85rem;
      border-radius: 10px;
    }
    .btn.primary{ background:#183055; border-color:#2b4e86; }
    .btn.accent{ background:var(--accent); color:#0b0d12; border:none; }
    .btn.warn{ background:#5b2330; border-color:#7b2d3f; }
    .btn:disabled{ opacity:.5; cursor:not-allowed; }
    .btn:hover:not(:disabled){ filter:brightness(1.05); transform:translateY(-1px); }
    .btn:active{ transform:translateY(0); }
    .note{ color:var(--muted); font-size:12px; margin-left:4px; white-space:nowrap; }

    /* Tabs (mobile only) */
    .mobile-tabs{
      display:none; grid-column:1 / -1; margin-top:6px; gap:8px; max-width:100%;
    }
    .tab{
      flex:1 1 0; text-align:center; border-radius:999px; padding:8px 12px; font-weight:700;
      border:1px solid var(--border); background:#0f1421; cursor:pointer; min-height:40px;
    }
    .tab.active{ background:#1a2440; border-color:#2b4e86; }

    .wrap{
      display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:12px;
      height: calc(100svh - var(--headH) - var(--safe-bottom));
      overflow:hidden; min-height:0; width:100%; max-width:100%;
    }
    @supports not (height:100svh){
      .wrap{ height: calc(100vh - var(--headH)); }
    }
    .col{ display:flex; flex-direction:column; min-height:0; height:100%; min-width:0; }
    .col.controls-panel{ overflow:hidden; }
    .controls-scroll{
      height:100%; min-height:0; overflow:auto; -webkit-overflow-scrolling:touch;
      scrollbar-gutter: stable both-edges; padding-right:6px;
    }

    .card{ background:var(--panel); border:1px solid var(--border); border-radius:14px; overflow:hidden; margin-bottom:12px; max-width:100%; }
    .card summary, .card h2{
      font-size:14px; letter-spacing:.3px; margin:0; padding:12px 14px;
      border-bottom:1px solid var(--border); color:#c9d5ea; list-style:none;
    }
    details.card > summary{ cursor:pointer; }
    details.card[open] > summary{ border-bottom:1px solid var(--border); }
    .card .body{ padding:12px; display:flex; flex-direction:column; gap:12px; }

    .drop{ background:#0f1421; border:2px dashed #2a3955; border-radius:12px; padding:14px; text-align:center; color:var(--muted); transition:.2s ease; cursor:pointer; }
    .drop:hover{ border-color:var(--accent); color:#cbd6ea; }
    .drop.dragover{ background:#0b1220; border-color:#a6da95; }

    .row{ display:grid; grid-template-columns: 1fr auto; gap:10px; align-items:center; }
    .controls{ display:grid; gap:10px; }

    label{ font-size:12px; color:var(--muted); }
    input[type="range"], select, input[type="number"], input[type="text"], input[type="color"]{
      width:100%; background:#0b1020; color:var(--text); border:1px solid var(--border);
      border-radius:10px; padding:10px; min-height:44px;
    }
    input[type="checkbox"]{ transform: translateY(2px); width:18px; height:18px; }

    /* Thumbnails (shared) */
    .thumbs{
      display:grid; grid-template-columns: repeat(auto-fill, minmax(88px, 1fr)); gap:8px; max-height:28vh; overflow:auto;
    }
    .thumb{ position:relative; border:1px solid var(--border); border-radius:10px; overflow:hidden; background:#0b1020; }
    .thumb img{ display:block; width:100%; height:70px; object-fit:cover; }
    .thumb .name{ font-size:10px; color:var(--muted); padding:6px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .thumb .pick,.thumb .trash{
      position:absolute; top:6px; background:rgba(0,0,0,.5); border:1px solid var(--border);
      padding:4px 8px; border-radius:999px; font-size:11px; cursor:pointer; min-height:28px;
    }
    .thumb .pick{ right:6px; } .thumb .trash{ left:6px; }

    /* Preview */
    .preview{
      position:relative; background:#0a0f1c; border:1px solid var(--border);
      border-radius:14px; height:100%; overflow:auto; min-height:260px;
      padding:8px; contain: layout paint; isolation:isolate;
      touch-action: none; max-width:100%;
    }
    canvas{
      max-width:none; max-height:none; background:#0a0f1c; image-rendering: optimizeQuality;
      transform-origin: top left; touch-action: none; display:block;
    }
    .zoombar{
      position:sticky; top:8px; left:0; display:flex; align-items:center; justify-content:flex-end;
      gap:6px; padding:0 8px; pointer-events:none; z-index:2; flex-wrap:wrap;
    }
    .zoombar .zbtn{
      pointer-events:auto; background:rgba(10,15,28,.85); border:1px solid var(--border);
      border-radius:10px; padding:8px 10px; font-weight:700; cursor:pointer; min-height:36px;
      color:#e6edf6;
    }
    .zoom-readout{
      position:sticky; top:8px; left:8px; pointer-events:none; font-size:12px; color:#9fb0ca;
      background:rgba(10,15,28,.7); border:1px solid var(--border); border-radius:8px; padding:6px 8px;
      display:inline-block;
    }

    @media (max-width:980px){
      header{ grid-template-columns: 1fr; }
      .head-actions{ order:3; flex-wrap:wrap; overflow:visible; row-gap:6px; }
      .head-actions .btn{ flex:1 1 calc(50% - 6px); }
      .note{ display:none; }

      .mobile-tabs{ display:flex; }
      .wrap{ grid-template-columns: 1fr; height: calc(100svh - var(--headH) - var(--safe-bottom)); }
      @supports not (height:100svh){
        .wrap{ height: calc(100vh - var(--headH)); }
      }
      .pane{ display:none; min-height:0; }
      .pane.active{ display:flex; }

      details.card.photos,
      details.card.templates,
      details.card.watermark,
      details.card.textmark{ overflow:hidden; }
      details.card.photos:not([open]) .body,
      details.card.templates:not([open]) .body,
      details.card.watermark:not([open]) .body,
      details.card.textmark:not([open]) .body{ display:none; }

      .thumbs{
        display:flex; gap:8px; overflow:auto; max-height:none; padding-bottom:2px;
      }
      .thumb{ flex:0 0 120px; }
    }

    .controls-scroll::-webkit-scrollbar{ width:10px; height:10px; }
    .controls-scroll::-webkit-scrollbar-thumb{ background:#2a3955; border-radius:8px; }
    .controls-scroll::-webkit-scrollbar-track{ background:#0b1020; }
  </style>
</head>
<body>
  <header id="appHeader">
    <div class="head-left">
      <h1>Watermark Studio</h1>
      <div class="sub">Drag & drop your logo and photos • Add text • Position, tilt, and save templates</div>
    </div>

    <div class="head-actions">
      <button class="btn" id="btn-export">Download Current</button>
      <button class="btn primary" id="btn-export-all">Process All as ZIP</button>
      <button class="btn warn" id="btn-remove-current" title="Remove current photo from list">Remove Current</button>

      <button class="btn accent" id="btn-choose-dir" title="Pick a folder to save images into">Choose Save Folder</button>
      <button class="btn" id="btn-save-current-to-dir" disabled>Save Current to Folder</button>
      <button class="btn" id="btn-save-all-to-dir" disabled>Process All to Folder</button>
      <span class="note" id="dir-note"></span>
    </div>

    <!-- Default tab = Controls -->
    <div class="mobile-tabs" role="tablist" aria-label="View switch">
      <button class="tab" id="tab-preview" aria-selected="false">Preview</button>
      <button class="tab active" id="tab-controls" aria-selected="true">Controls</button>
    </div>
  </header>

  <div class="wrap">
    <!-- LEFT / PANEL: CONTROLS  (Default active on mobile) -->
    <div class="col controls-panel pane active" id="pane-controls" aria-labelledby="tab-controls">
      <div class="controls-scroll">

        <!-- 1) Templates -->
        <details class="card templates" open>
          <summary>Templates</summary>
          <div class="body">
            <div class="row" style="grid-template-columns: 1fr auto;">
              <input type="text" id="tpl-name" placeholder="Template name" />
              <button class="btn" id="btn-save-tpl">Save</button>
            </div>
            <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
              <button class="btn" id="btn-export-tpl" title="Save template to a .json file">Export Template</button>
              <input id="tpl-import-input" type="file" accept="application/json" style="display:none" />
              <button class="btn" id="btn-import-tpl" title="Load template from a .json file">Import Template</button>
              <button class="btn warn" id="btn-clear-templates" title="Delete ALL saved templates">Clear All</button>
            </div>
            <div id="tpl-list" class="controls"></div>
          </div>
        </details>

        <!-- 2) Watermark (Logo) -->
        <details class="card watermark" open>
          <summary>Watermark (Logo)</summary>
          <div class="body">
            <div id="logo-drop" class="drop" tabindex="0">
              <div><strong>Drop logo here</strong> or tap to browse</div>
              <div class="muted">PNG with transparency recommended</div>
              <input id="logo-input" type="file" accept="image/*" style="display:none" />
            </div>

            <!-- Logo thumbnail (single item, similar style to Photos) -->
            <div class="thumbs" id="logo-thumbs"></div>

            <div class="controls">
              <div class="row">
                <label>Scale (% of photo width)</label>
                <input id="scale" type="range" min="1" max="100" value="25" />
              </div>
              <div class="row">
                <label>Opacity</label>
                <input id="opacity" type="range" min="1" max="100" value="70" />
              </div>
              <div class="row">
                <label>Anchor</label>
                <select id="anchor">
                  <option value="top-left">Top Left</option>
                  <option value="top-center">Top Center</option>
                  <option value="top-right">Top Right</option>
                  <option value="center-left">Center Left</option>
                  <option value="center">Center</option>
                  <option value="center-right">Center Right</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="bottom-center" selected>Bottom Center</option>
                  <option value="bottom-right">Bottom Right</option>
                </select>
              </div>
              <div class="row">
                <label>Offset X (px)</label>
                <input id="offsetX" type="number" value="0" />
              </div>
              <div class="row">
                <label>Offset Y (px)</label>
                <input id="offsetY" type="number" value="-20" />
              </div>
              <div class="row">
                <label>Allow drag on preview</label>
                <input id="dragToggle" type="checkbox" checked />
              </div>
            </div>
          </div>
        </details>

        <!-- 3) Photos -->
        <details class="card photos" open>
          <summary>Photos</summary>
          <div class="body">
            <div id="photo-drop" class="drop" tabindex="0">
              <div><strong>Drop photos here</strong> or tap to browse</div>
              <div class="muted">JPG/PNG; you can add multiple</div>
              <input id="photo-input" type="file" accept="image/*" multiple style="display:none" />
            </div>
            <div class="thumbs" id="photo-thumbs"></div>
          </div>
        </details>

        <!-- 4) Text Watermark -->
        <details class="card textmark" open>
          <summary>Text Watermark</summary>
          <div class="body">
            <div class="controls">
              <div class="row">
                <label>Text</label>
                <input id="txt-text" type="text" placeholder="Type your watermark text" />
              </div>
              <div class="row">
                <label>Font family</label>
                <select id="txt-font">
                  <option value="Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial">Sans</option>
                  <option value="Georgia, 'Times New Roman', Times, serif">Serif</option>
                  <option value="'Courier New', Courier, monospace">Mono</option>
                </select>
              </div>
              <div class="row">
                <label>Size (px)</label>
                <input id="txt-size" type="number" value="48" min="6" />
              </div>
              <div class="row">
                <label>Color</label>
                <input id="txt-color" type="color" value="#ffffff" />
              </div>
              <div class="row">
                <label>Opacity</label>
                <input id="txt-opacity" type="range" min="1" max="100" value="70" />
              </div>
              <div class="row">
                <label>Tilt (°)</label>
                <input id="txt-rot" type="range" min="-180" max="180" value="0" />
              </div>

              <div class="row">
                <label>Text Anchor</label>
                <select id="txt-anchor">
                  <option value="top-left">Top Left</option>
                  <option value="top-center">Top Center</option>
                  <option value="top-right">Top Right</option>
                  <option value="center-left">Center Left</option>
                  <option value="center">Center</option>
                  <option value="center-right">Center Right</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="bottom-center">Bottom Center</option>
                  <option value="bottom-right">Bottom Right</option>
                </select>
              </div>
              <div class="row">
                <label>Text Offset X (px)</label>
                <input id="txt-offx" type="number" value="0" />
              </div>
              <div class="row">
                <label>Text Offset Y (px)</label>
                <input id="txt-offy" type="number" value="0" />
              </div>

              <div style="display:flex; gap:8px; flex-wrap:wrap;">
                <button class="btn" id="btn-reset-tilt">Reset Tilt</button>
                <label style="display:flex; align-items:center; gap:8px;">
                  <span class="muted">Enable text drag</span>
                  <input id="txt-drag-toggle" type="checkbox" checked />
                </label>
              </div>
            </div>
          </div>
        </details>

      </div>
    </div>

    <!-- RIGHT / PANE: PREVIEW (not active by default on mobile) -->
    <div class="col pane" id="pane-preview" aria-labelledby="tab-preview">
      <div class="card" style="min-height:0; height:100%;">
        <h2>Preview</h2>
        <div class="body" style="height: calc(100% - 44px);">
          <div class="preview" id="preview">
            <div class="zoombar" id="zoombar">
              <button class="zbtn" id="zoom-out" title="Zoom out (Ctrl/⌘ + scroll)">−</button>
              <button class="zbtn" id="zoom-in"  title="Zoom in (Ctrl/⌘ + scroll)">+</button>
              <button class="zbtn" id="zoom-fit" title="Fit to screen">Fit</button>
              <button class="zbtn" id="zoom-100" title="Actual size">100%</button>
            </div>
            <div class="zoom-readout" id="zoom-readout">100%</div>
            <canvas id="canvas"></canvas>
          </div>

          <div class="row">
            <div class="muted">Format</div>
            <select id="format">
              <option value="image/png">PNG</option>
              <option value="image/jpeg">JPEG</option>
            </select>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Optional zipping for batch export -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>

  <script>
    /* Header height calibration */
    (function calibrateHeader() {
      const header = document.getElementById('appHeader');
      const set = () => {
        const h = Math.round(header.getBoundingClientRect().height);
        document.documentElement.style.setProperty('--headH', h + 'px');
      };
      set();
      new ResizeObserver(set).observe(header);
      window.addEventListener('orientationchange', set);
      window.addEventListener('resize', set);
    })();

    /* Mobile tab switch — default to CONTROLS on mobile */
    (function tabs(){
      const tabPrev = document.getElementById('tab-preview');
      const tabCtrl = document.getElementById('tab-controls');
      const panePrev = document.getElementById('pane-preview');
      const paneCtrl = document.getElementById('pane-controls');

      function activate(which){
        const isPrev = which === 'preview';
        tabPrev.classList.toggle('active', isPrev);
        tabPrev.setAttribute('aria-selected', isPrev);
        panePrev.classList.toggle('active', isPrev);

        tabCtrl.classList.toggle('active', !isPrev);
        tabCtrl.setAttribute('aria-selected', !isPrev);
        paneCtrl.classList.toggle('active', !isPrev);
      }

      tabPrev?.addEventListener('click', () => activate('preview'));
      tabCtrl?.addEventListener('click', () => activate('controls'));

      const mm = window.matchMedia('(max-width: 980px)');
      const handle = () => {
        if (mm.matches) activate('controls'); // default controls on small screens
        else { panePrev.classList.add('active'); paneCtrl.classList.add('active'); }
      };
      handle();
      mm.addEventListener('change', handle);
    })();

    // ---------- State ----------
    const state = {
      logoImg: null,
      logoName: '',
      photos: [], // {name, img}
      currentIndex: -1,
      settings: { scalePct: 25, opacity: 0.7, anchor: 'bottom-center', offsetX: 0, offsetY: -20 },
      drag:   { enabled: true, active: false, dx:0, dy:0, id:null },
      text:   {
        value: '', fontFamily: "Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial",
        sizePx: 48, color: '#ffffff', opacity: 0.7, rotDeg: 0,
        anchor: 'center', offsetX: 0, offsetY: 0,
        dragEnabled: true, drag: { active:false, dx:0, dy:0, id:null }
      },
      outDir: null, outDirName: '',
      zoom: 1, zoomMode: 'fit'
    };

    // ---------- Elements ----------
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
    const previewEl = document.getElementById('preview');
    const zoomReadout = document.getElementById('zoom-readout');

    const logoDrop = document.getElementById('logo-drop');
    const logoInput = document.getElementById('logo-input');
    const logoThumbs = document.getElementById('logo-thumbs');

    const photoDrop = document.getElementById('photo-drop');
    const photoInput = document.getElementById('photo-input');
    const thumbs = document.getElementById('photo-thumbs');

    const scaleEl = document.getElementById('scale');
    const opacityEl = document.getElementById('opacity');
    const anchorEl = document.getElementById('anchor');
    const offsetXEl = document.getElementById('offsetX');
    const offsetYEl = document.getElementById('offsetY');
    const dragToggle = document.getElementById('dragToggle');
    const formatEl = document.getElementById('format');

    const exportBtn = document.getElementById('btn-export');
    const exportAllBtn = document.getElementById('btn-export-all');
    const removeCurrentBtn = document.getElementById('btn-remove-current');

    const chooseDirBtn = document.getElementById('btn-choose-dir');
    const saveCurrentToDirBtn = document.getElementById('btn-save-current-to-dir');
    const saveAllToDirBtn = document.getElementById('btn-save-all-to-dir');
    const dirNote = document.getElementById('dir-note');

    const txtTextEl = document.getElementById('txt-text');
    const txtFontEl = document.getElementById('txt-font');
    const txtSizeEl = document.getElementById('txt-size');
    const txtColorEl = document.getElementById('txt-color');
    const txtOpacityEl = document.getElementById('txt-opacity');
    const txtRotEl = document.getElementById('txt-rot');
    const txtDragToggle = document.getElementById('txt-drag-toggle');
    const resetTiltBtn = document.getElementById('btn-reset-tilt');
    const txtAnchorEl = document.getElementById('txt-anchor');
    const txtOffXEl  = document.getElementById('txt-offx');
    const txtOffYEl  = document.getElementById('txt-offy');

    const zIn = document.getElementById('zoom-in');
    const zOut = document.getElementById('zoom-out');
    const zFit = document.getElementById('zoom-fit');
    const z100 = document.getElementById('zoom-100');

    // ---------- Helpers ----------
    const raf = (()=>{ let p=false; return (fn)=>{ if(p) return; p=true; requestAnimationFrame(()=>{ p=false; fn(); }); }; })();

    function readAsImage(file){
      return new Promise((resolve, reject) => {
        const fr = new FileReader();
        fr.onload = () => {
          const img = new Image();
          img.onload = () => resolve({ img, name:file.name });
          img.onerror = reject;
          img.src = fr.result;
        };
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });
    }

    // ----- Geometry (LOGO) -----
    function logoDims(){
      if (!state.logoImg || !state.photos[state.currentIndex]) return { w:0, h:0 };
      const targetW = canvas.width * (state.settings.scalePct / 100);
      const aspect = state.logoImg.naturalWidth / state.logoImg.naturalHeight;
      return { w: targetW, h: targetW / aspect };
    }
    function logoBasePos(){ // top-left of logo when offsets = 0 for current anchor
      const { w, h } = logoDims();
      const cx = canvas.width/2, cy = canvas.height/2;
      switch (state.settings.anchor){
        case 'top-left':     return { x:0, y:0 };
        case 'top-center':   return { x:cx - w/2, y:0 };
        case 'top-right':    return { x:canvas.width - w, y:0 };
        case 'center-left':  return { x:0, y:cy - h/2 };
        case 'center':       return { x:cx - w/2, y:cy - h/2 };
        case 'center-right': return { x:canvas.width - w, y:cy - h/2 };
        case 'bottom-left':  return { x:0, y:canvas.height - h };
        case 'bottom-center':return { x:cx - w/2, y:canvas.height - h };
        case 'bottom-right': return { x:canvas.width - w, y:canvas.height - h };
      }
      return { x:0, y:0 };
    }
    function getLogoAbs(){ // absolute TL position on canvas
      const base = logoBasePos();
      return { x: base.x + Number(state.settings.offsetX||0), y: base.y + Number(state.settings.offsetY||0) };
    }
    function setLogoAbs(x, y){ // set offsets so that absolute TL = (x,y)
      const base = logoBasePos();
      state.settings.offsetX = Math.round(x - base.x);
      state.settings.offsetY = Math.round(y - base.y);
      offsetXEl.value = state.settings.offsetX;
      offsetYEl.value = state.settings.offsetY;
      raf(draw);
    }
    // SNAP: when anchor changes, move logo to that anchor (offsets reset to 0)
    function setLogoAnchorSnap(newAnchor){
      state.settings.anchor = newAnchor;
      state.settings.offsetX = 0;
      state.settings.offsetY = 0;
      offsetXEl.value = 0; offsetYEl.value = 0;
      raf(draw);
    }

    // ----- Geometry (TEXT) -----
    function measureTextSize(){
      const tctx = document.createElement('canvas').getContext('2d');
      tctx.font = `${state.text.sizePx}px ${state.text.fontFamily}`;
      const w = Math.ceil(tctx.measureText(state.text.value || '').width);
      const h = state.text.sizePx;
      return { w, h };
    }
    function textBasePos(){
      const { w, h } = measureTextSize();
      const cx = canvas.width/2, cy = canvas.height/2;
      switch (state.text.anchor){
        case 'top-left':     return { x:0, y:0 };
        case 'top-center':   return { x:cx - w/2, y:0 };
        case 'top-right':    return { x:canvas.width - w, y:0 };
        case 'center-left':  return { x:0, y:cy - h/2 };
        case 'center':       return { x:cx - w/2, y:cy - h/2 };
        case 'center-right': return { x:canvas.width - w, y:cy - h/2 };
        case 'bottom-left':  return { x:0, y:canvas.height - h };
        case 'bottom-center':return { x:cx - w/2, y:canvas.height - h };
        case 'bottom-right': return { x:canvas.width - w, y:canvas.height - h };
      }
      return { x:0, y:0 };
    }
    function getTextAbs(){ const b = textBasePos(); return { x: b.x + Number(state.text.offsetX||0), y: b.y + Number(state.text.offsetY||0) }; }
    function setTextAbs(x, y){ const b = textBasePos(); state.text.offsetX = Math.round(x - b.x); state.text.offsetY = Math.round(y - b.y); txtOffXEl.value = state.text.offsetX; txtOffYEl.value = state.text.offsetY; raf(draw); }
    function setTextAnchorSnap(newAnchor){ state.text.anchor = newAnchor; state.text.offsetX = 0; state.text.offsetY = 0; txtOffXEl.value = 0; txtOffYEl.value = 0; raf(draw); }

    // ---------- Zoom (preview-only) ----------
    function computeFitZoom(){
      if (!canvas.width || !canvas.height) return 1;
      const pad = 16;
      const availW = Math.max(100, previewEl.clientWidth - pad);
      const availH = Math.max(100, previewEl.clientHeight - pad);
      return Math.min(availW / canvas.width, availH / canvas.height);
    }
    function applyZoom(){
      if (state.zoomMode === 'fit') state.zoom = computeFitZoom();
      canvas.style.transform = `scale(${state.zoom})`; // CSS-only, export unaffected
      zoomReadout.textContent = `${Math.round(state.zoom*100)}%`;
    }
    function setZoom(z, mode='manual'){ state.zoom = Math.min(8, Math.max(0.05, z)); state.zoomMode = mode; applyZoom(); }
    function zoomStep(dir){ const step = dir > 0 ? 1.1 : 1/1.1; setZoom(state.zoom * step, 'manual'); }
    new ResizeObserver(() => { if (state.zoomMode==='fit') applyZoom(); }).observe(previewEl);

    // ---------- Drawing ----------
    function draw(){
      const photo = state.photos[state.currentIndex];
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (!photo) { applyZoom(); return; }

      // Always render at photo's native resolution (preview zoom is CSS only)
      canvas.width = photo.img.naturalWidth;
      canvas.height = photo.img.naturalHeight;

      ctx.drawImage(photo.img, 0, 0);

      if (state.logoImg){
        const { w, h } = logoDims();
        const p = getLogoAbs();
        ctx.globalAlpha = state.settings.opacity;
        ctx.drawImage(state.logoImg, p.x, p.y, w, h);
        ctx.globalAlpha = 1;
      }

      if (state.text.value){
        const p = getTextAbs();
        const t = state.text;
        ctx.save();
        ctx.globalAlpha = t.opacity;
        ctx.font = `${t.sizePx}px ${t.fontFamily}`;
        ctx.fillStyle = t.color;
        ctx.textBaseline = 'top';
        ctx.translate(p.x, p.y);
        ctx.rotate((t.rotDeg || 0) * Math.PI / 180);
        ctx.fillText(t.value, 0, 0);
        ctx.restore();
      }

      applyZoom();
    }

    function setCurrent(index){ state.currentIndex = index; raf(draw); }

    // ---------- Thumbnails ----------
    function refreshPhotoThumbs(){
      thumbs.innerHTML = '';
      state.photos.forEach((p,i) => {
        const div = document.createElement('div');
        div.className = 'thumb';
        div.innerHTML = `<img alt="thumb"/><div class="name">${p.name}</div><div class="pick">Use</div><div class="trash">Del</div>`;
        div.querySelector('img').src = p.img.src;
        div.querySelector('.pick').onclick = () => setCurrent(i);
        div.querySelector('.trash').onclick = () => removePhotoAt(i);
        thumbs.appendChild(div);
      });
      if (state.currentIndex === -1 && state.photos.length) setCurrent(0);
    }
    function renderLogoThumb(){
      logoThumbs.innerHTML = '';
      if (!state.logoImg) return;
      const div = document.createElement('div');
      div.className = 'thumb';
      div.innerHTML = `
        <img alt="logo-thumb"/>
        <div class="name">${state.logoName || 'Logo'}</div>
        <div class="pick">Replace</div>
        <div class="trash">Clear</div>
      `;
      div.querySelector('img').src = state.logoImg.src;
      div.querySelector('.pick').onclick = () => logoInput.click();
      div.querySelector('.trash').onclick = () => { state.logoImg = null; state.logoName=''; renderLogoThumb(); raf(draw); };
      logoThumbs.appendChild(div);
    }

    function removePhotoAt(i){
      if (i < 0 || i >= state.photos.length) return;
      state.photos.splice(i,1);
      if (!state.photos.length){
        state.currentIndex = -1; ctx.clearRect(0,0,canvas.width,canvas.height);
      } else if (state.currentIndex >= state.photos.length){
        state.currentIndex = state.photos.length - 1;
      }
      refreshPhotoThumbs(); raf(draw);
    }

    function bindDropzone(zoneEl, inputEl, onFiles){
      const openPicker = () => inputEl.click();
      zoneEl.addEventListener('click', openPicker);
      zoneEl.addEventListener('keydown', e => { if (e.key === 'Enter' || e.key === ' ') openPicker(); });
      zoneEl.addEventListener('dragover', e => { e.preventDefault(); zoneEl.classList.add('dragover'); });
      zoneEl.addEventListener('dragleave', () => zoneEl.classList.remove('dragover'));
      zoneEl.addEventListener('drop', async e => {
        e.preventDefault(); zoneEl.classList.remove('dragover');
        const files = [...e.dataTransfer.files].filter(f => f.type.startsWith('image/'));
        if (files.length) onFiles(files);
      });
      inputEl.addEventListener('change', () => {
        const files = [...inputEl.files];
        if (files.length) onFiles(files);
        inputEl.value='';
      });
    }

    bindDropzone(logoDrop, logoInput, async files => {
      const f = files[0];
      const { img, name } = await readAsImage(f);
      state.logoImg = img; state.logoName = name || 'Logo';
      renderLogoThumb(); raf(draw);
    });

    bindDropzone(photoDrop, photoInput, async files => {
      for (const f of files){
        const { img, name } = await readAsImage(f);
        state.photos.push({ img, name });
      }
      refreshPhotoThumbs(); raf(draw);
    });

    // ---------- Controls — Logo ----------
    scaleEl.addEventListener('input', () => { state.settings.scalePct = Number(scaleEl.value); raf(draw); });
    opacityEl.addEventListener('input', () => { state.settings.opacity = Number(opacityEl.value)/100; raf(draw); });

    // Anchor change: snap to selected anchor (offsets = 0)
    anchorEl.addEventListener('change', () => setLogoAnchorSnap(anchorEl.value));

    // Manual offsets: update and draw (position stays aligned by formula)
    offsetXEl.addEventListener('input', () => { state.settings.offsetX = Number(offsetXEl.value||0); raf(draw); });
    offsetYEl.addEventListener('input', () => { state.settings.offsetY = Number(offsetYEl.value||0); raf(draw); });

    dragToggle.addEventListener('change', () => { state.drag.enabled = dragToggle.checked; });

    // ---------- Controls — Text ----------
    txtTextEl.addEventListener('input', () => { state.text.value = txtTextEl.value; raf(draw); });
    txtFontEl.addEventListener('change', () => { state.text.fontFamily = txtFontEl.value; raf(draw); });
    txtSizeEl.addEventListener('input', () => { state.text.sizePx = Math.max(6, Number(txtSizeEl.value||0)); raf(draw); });
    txtColorEl.addEventListener('input', () => { state.text.color = txtColorEl.value; raf(draw); });
    txtOpacityEl.addEventListener('input', () => { state.text.opacity = Number(txtOpacityEl.value)/100; raf(draw); });
    txtRotEl.addEventListener('input', () => { state.text.rotDeg = Number(txtRotEl.value); raf(draw); });

    // (Optional symmetry) Text anchor snap
    txtAnchorEl.addEventListener('change', () => setTextAnchorSnap(txtAnchorEl.value));
    txtOffXEl.addEventListener('input', () => { state.text.offsetX = Number(txtOffXEl.value||0); raf(draw); });
    txtOffYEl.addEventListener('input', () => { state.text.offsetY = Number(txtOffYEl.value||0); raf(draw); });

    txtDragToggle.addEventListener('change', () => { state.text.dragEnabled = txtDragToggle.checked; });
    resetTiltBtn.addEventListener('click', () => { state.text.rotDeg = 0; txtRotEl.value = 0; raf(draw); });

    removeCurrentBtn.addEventListener('click', () => { if (state.currentIndex !== -1) removePhotoAt(state.currentIndex); });

    // ---------- Pointer interactions (drag updates offsets, keeps alignment) ----------
    function getPointerCanvasXY(e){
      const rect = canvas.getBoundingClientRect();
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
    }
    function measureTextRectForHit(){
      if (!state.text.value) return null;
      const tctx = document.createElement('canvas').getContext('2d');
      tctx.font = `${state.text.sizePx}px ${state.text.fontFamily}`;
      const w = Math.ceil(tctx.measureText(state.text.value).width);
      const h = state.text.sizePx;
      const p = getTextAbs();
      const rad = (state.text.rotDeg||0) * Math.PI/180;
      const cos = Math.abs(Math.cos(rad)), sin = Math.abs(Math.sin(rad));
      return { x:p.x, y:p.y, w:Math.ceil(w*cos + h*sin), h:Math.ceil(w*sin + h*cos) };
    }
    function pointInRect(x,y,r){ return x>=r.x && x<=r.x+r.w && y>=r.y && y<=r.y+r.h; }

    let dragTarget = null; // 'text' | 'logo'
    let lastTapTime = 0;

    canvas.addEventListener('pointerdown', (e) => {
      if (state.currentIndex === -1) return;
      const now = Date.now();
      if (now - lastTapTime < 300){ // double-tap zoom in
        const step = 1.1; setZoom(state.zoom * step, 'manual'); lastTapTime = 0; return;
      }
      lastTapTime = now;

      e.preventDefault();
      canvas.setPointerCapture(e.pointerId);

      const { x, y } = getPointerCanvasXY(e);

      const tr = measureTextRectForHit();
      if (state.text.dragEnabled && tr && pointInRect(x,y,tr)){
        dragTarget = 'text';
        state.text.drag.active = true;
        state.text.drag.id = e.pointerId;
        const p = getTextAbs();
        state.text.drag.dx = x - p.x;
        state.text.drag.dy = y - p.y;
        return;
      }

      if (state.drag.enabled && state.logoImg){
        const { w, h } = logoDims();
        const p = getLogoAbs();
        const r = { x:p.x, y:p.y, w, h };
        if (pointInRect(x,y,r)){
          dragTarget = 'logo';
          state.drag.active = true;
          state.drag.id = e.pointerId;
          state.drag.dx = x - p.x;
          state.drag.dy = y - p.y;
        }
      }
    }, { passive:false });

    canvas.addEventListener('pointermove', (e) => {
      if (e.pointerId !== state.drag.id && e.pointerId !== state.text.drag.id) return;
      const { x, y } = getPointerCanvasXY(e);
      if (dragTarget === 'text' && state.text.drag.active){
        e.preventDefault();
        setTextAbs(Math.round(x - state.text.drag.dx), Math.round(y - state.text.drag.dy));
      } else if (dragTarget === 'logo' && state.drag.active){
        e.preventDefault();
        setLogoAbs(Math.round(x - state.drag.dx), Math.round(y - state.drag.dy));
      }
    }, { passive:false });

    function endDrag(){
      dragTarget = null;
      state.drag.active = false; state.drag.id = null;
      state.text.drag.active = false; state.text.drag.id = null;
    }
    canvas.addEventListener('pointerup', endDrag, { passive:true });
    canvas.addEventListener('pointercancel', endDrag, { passive:true });
    canvas.addEventListener('lostpointercapture', endDrag, { passive:true });

    // ---------- Zoom controls ----------
    previewEl.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey){
        e.preventDefault();
        if (e.deltaY < 0) zoomStep(+1); else zoomStep(-1);
      }
    }, { passive:false });
    zIn.addEventListener('click',  () => zoomStep(+1));
    zOut.addEventListener('click', () => zoomStep(-1));
    zFit.addEventListener('click', () => setZoom(computeFitZoom(), 'fit'));
    z100.addEventListener('click', () => setZoom(1, 'manual'));

    // ---------- Export (full-res; zoom ignored) ----------
    function downloadCurrent(){
      const photo = state.photos[state.currentIndex];
      if (!photo) return alert('Add a photo first.');
      const mime = formatEl.value;
      const name = photo.name.replace(/\.[^.]+$/, '');
      // draw() always renders full-res; ensure it ran this frame
      raf(() => {
        canvas.toBlob((blob) => {
          if (!blob) return;
          const ext = mime === 'image/png' ? 'png' : 'jpg';
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = `${name}_watermarked.${ext}`;
          a.click();
          URL.revokeObjectURL(a.href);
        }, mime, mime === 'image/jpeg' ? 0.92 : undefined);
      });
    }

    async function processAllZip(){
      if (!state.photos.length) return alert('Add some photos first.');
      if (typeof JSZip === 'undefined'){ alert('JSZip not loaded. Try again or download individually.'); return; }
      const zip = new JSZip();
      const mime = formatEl.value;
      for (let i=0;i<state.photos.length;i++){
        setCurrent(i);
        await new Promise(r => requestAnimationFrame(r)); // ensure draw at full-res
        const blob = await new Promise(res => canvas.toBlob(res, mime, mime === 'image/jpeg' ? 0.92 : undefined));
        const base = state.photos[i].name.replace(/\.[^.]+$/, '');
        const name = `${base}_watermarked${mime==='image/png'?'.png':'.jpg'}`;
        zip.file(name, blob);
      }
      const out = await zip.generateAsync({ type:'blob' });
      if ('showSaveFilePicker' in window){
        try{
          const handle = await window.showSaveFilePicker({
            suggestedName:'watermarked_photos.zip',
            types:[{ description:'ZIP Archive', accept:{'application/zip':['.zip']} }]
          });
          const writable = await handle.createWritable();
          await writable.write(out); await writable.close();
          return;
        }catch(e){ /* cancelled */ }
      }
      saveAs(out, 'watermarked_photos.zip');
    }

    exportBtn.addEventListener('click', downloadCurrent);
    exportAllBtn.addEventListener('click', processAllZip);

    // ---------- Save-to-folder helpers ----------
    function fsSupported(){ return 'showDirectoryPicker' in window; }
    function updateDirUI(){
      const on = !!state.outDir;
      saveCurrentToDirBtn.disabled = !on;
      saveAllToDirBtn.disabled = !on;
      dirNote.textContent = on ? `Saving to: ${state.outDirName}` :
        (fsSupported() ? 'Pick a folder to save images there.' : 'Folder saving not supported in this browser.');
      chooseDirBtn.style.display = fsSupported() ? '' : 'none';
      saveCurrentToDirBtn.style.display = fsSupported() ? '' : 'none';
      saveAllToDirBtn.style.display  = fsSupported() ? '' : 'none';
    }
    async function ensureDirPermission(){
      if (!state.outDir) return false;
      if (!state.outDir.queryPermission) return true;
      const q = await state.outDir.queryPermission({ mode:'readwrite' });
      if (q === 'granted') return true;
      if (q === 'prompt'){
        const r = await state.outDir.requestPermission({ mode:'readwrite' });
        return r === 'granted';
      }
      return false;
    }
    chooseDirBtn.addEventListener('click', async () => {
      if (!fsSupported()){ alert('Your browser does not support choosing a save folder. Try Chrome/Edge.'); return; }
      try{
        const dir = await window.showDirectoryPicker({ mode:'readwrite' });
        state.outDir = dir;
        state.outDirName = dir.name || 'Selected Folder';
        const ok = await ensureDirPermission();
        if (!ok){ alert('Permission denied for that folder.'); state.outDir = null; }
      }catch(e){ /* cancelled */ }
      updateDirUI();
    });
    async function saveBlobToDir(filename, blob){
      if (!await ensureDirPermission()){ alert('No permission to write to the chosen folder.'); return; }
      async function fileExists(dir, name){ try{ await dir.getFileHandle(name, { create:false }); return true; } catch{ return false; } }
      function splitName(filename){ const i=filename.lastIndexOf('.'); return i>0?{base:filename.slice(0,i),ext:filename.slice(i)}:{base:filename,ext:''}; }
      async function uniqueName(dir, desired){
        if (!(await fileExists(dir, desired))) return desired;
        const { base, ext } = splitName(desired);
        for (let i=1;i<10000;i++){ const cand = `${base} (${i})${ext}`; if (!(await fileExists(dir, cand))) return cand; }
        return `${base} (${Date.now()})${ext}`;
      }
      const finalName = await uniqueName(state.outDir, filename);
      const fileHandle = await state.outDir.getFileHandle(finalName, { create:true });
      const writable = await fileHandle.createWritable();
      await writable.write(blob); await writable.close();
      return finalName;
    }
    async function saveCurrentToDir(){
      const photo = state.photos[state.currentIndex];
      if (!photo) return alert('Add a photo first.');
      const mime = formatEl.value;
      const base = photo.name.replace(/\.[^.]+$/, '');
      await new Promise(r => requestAnimationFrame(r)); // ensure draw
      const blob = await new Promise(res => canvas.toBlob(res, mime, mime === 'image/jpeg' ? 0.92 : undefined));
      const savedAs = await saveBlobToDir(`${base}_watermarked${mime==='image/png'?'.png':'.jpg'}`, blob);
      if (savedAs) dirNote.textContent = `Saved ${savedAs} to: ${state.outDirName}`;
    }
    async function saveAllToDir(){
      if (!state.photos.length) return alert('Add some photos first.');
      const mime = formatEl.value;
      for (let i=0;i<state.photos.length;i++){
        setCurrent(i);
        await new Promise(r => requestAnimationFrame(r));
        const base = state.photos[i].name.replace(/\.[^.]+$/, '');
        const blob = await new Promise(res => canvas.toBlob(res, mime, mime === 'image/jpeg' ? 0.92 : undefined));
        await saveBlobToDir(`${base}_watermarked${mime==='image/png'?'.png':'.jpg'}`, blob);
      }
      dirNote.textContent = `Saved ${state.photos.length} file(s) to: ${state.outDirName}`;
    }
    saveCurrentToDirBtn.addEventListener('click', saveCurrentToDir);
    saveAllToDirBtn.addEventListener('click', saveAllToDir);
    updateDirUI();

    // ---------- Templates ----------
    const LS_KEY = 'wm_templates_v3';
    function getTemplates(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)) || []; } catch{ return []; } }
    function setTemplates(list){ localStorage.setItem(LS_KEY, JSON.stringify(list)); }
    function serializeTemplate(name){
      let logoDataUrl = null;
      if (state.logoImg){
        const tmp = document.createElement('canvas');
        tmp.width = state.logoImg.naturalWidth; tmp.height = state.logoImg.naturalHeight;
        tmp.getContext('2d').drawImage(state.logoImg, 0, 0);
        logoDataUrl = tmp.toDataURL('image/png');
      }
      return { name, settings:{...state.settings}, logo:{ dataUrl:logoDataUrl }, text:{...state.text}, createdAt:Date.now(), version:3 };
    }
    function saveTemplate(name){
      if (!name){ alert('Enter a template name.'); return; }
      const tpl = serializeTemplate(name);
      const list = getTemplates().filter(t => t.name !== name);
      list.unshift(tpl); setTemplates(list); renderTplList(); alert('Template saved.');
    }
    function applyTemplate(tpl){
      if (tpl.logo?.dataUrl){
        const img = new Image();
        img.onload = () => { state.logoImg = img; state.logoName = 'Logo'; renderLogoThumb(); restoreStateFromTpl(tpl); };
        img.src = tpl.logo.dataUrl;
      } else {
        state.logoImg = null; state.logoName = ''; renderLogoThumb(); restoreStateFromTpl(tpl);
      }
    }
    function restoreStateFromTpl(tpl){
      state.settings = { ...state.settings, ...tpl.settings };
      if (tpl.text) state.text = { ...state.text, ...tpl.text };
      syncControls(); raf(draw);
    }
    function deleteTemplate(name){
      if (!confirm(`Delete template "${name}"?`)) return;
      const list = getTemplates().filter(t => t.name !== name);
      setTemplates(list); renderTplList();
    }
    function renderTplList(){
      const list = getTemplates();
      const tplListEl = document.getElementById('tpl-list');
      tplListEl.innerHTML = '';
      if (!list.length){
        const p = document.createElement('div'); p.className='muted'; p.textContent='No templates yet.';
        tplListEl.appendChild(p); return;
      }
      list.forEach(t => {
        const row = document.createElement('div');
        row.className = 'template-row';
        row.innerHTML = `
          <div>
            <div style="font-size:12px; font-weight:700;">${t.name}</div>
            <div class="muted" style="font-size:10px;">Scale ${t.settings.scalePct}% · Logo ${Math.round(t.settings.opacity*100)}% · ${t.settings.anchor}${t.text?.value ? ' · Text ✓' : ''}</div>
          </div>
          <button class="btn" data-act="load">Load</button>
          <button class="btn" data-act="rename">Rename</button>
          <button class="btn" data-act="export">Export</button>
          <button class="btn warn" data-act="delete">Delete</button>
        `;
        row.querySelector('[data-act="load"]').onclick = () => applyTemplate(t);
        row.querySelector('[data-act="delete"]').onclick = () => deleteTemplate(t.name);
        row.querySelector('[data-act="rename"]').onclick = () => {
          const nn = prompt('New name', t.name); if (!nn) return;
          const list2 = getTemplates(); const idx = list2.findIndex(x => x.name === t.name);
          if (idx >= 0){ list2[idx].name = nn; setTemplates(list2); renderTplList(); }
        };
        row.querySelector('[data-act="export"]').onclick = () => {
          const blob = new Blob([JSON.stringify(t, null, 2)], { type:'application/json' });
          saveAs(blob, `${t.name || 'template'}.json`);
        };
        tplListEl.appendChild(row);
      });
    }

    document.getElementById('btn-save-tpl').addEventListener('click', () => saveTemplate(document.getElementById('tpl-name').value.trim()));
    document.getElementById('btn-export-tpl').addEventListener('click', () => {
      const name = document.getElementById('tpl-name').value.trim() || 'template';
      const blob = new Blob([JSON.stringify(serializeTemplate(name), null, 2)], { type:'application/json' });
      saveAs(blob, `${name}.json`);
    });
    document.getElementById('btn-import-tpl').addEventListener('click', () => document.getElementById('tpl-import-input').click());
    document.getElementById('tpl-import-input').addEventListener('change', () => {
      const f = document.getElementById('tpl-import-input').files[0]; if (!f) return;
      const fr = new FileReader();
      fr.onload = () => {
        try{
          const tpl = JSON.parse(fr.result);
          const list = getTemplates().filter(t => t.name !== tpl.name);
          list.unshift(tpl); setTemplates(list); renderTplList(); applyTemplate(tpl);
        }catch(e){ alert('Failed to import template: ' + e.message); }
      };
      fr.readAsText(f); document.getElementById('tpl-import-input').value='';
    });
    document.getElementById('btn-clear-templates').addEventListener('click', () => {
      if (!getTemplates().length){ alert('No templates saved.'); return; }
      if (confirm('Delete ALL saved templates? This cannot be undone.')){ setTemplates([]); renderTplList(); }
    });

    function syncControls(){
      scaleEl.value = state.settings.scalePct;
      opacityEl.value = Math.round(state.settings.opacity * 100);
      anchorEl.value = state.settings.anchor;
      offsetXEl.value = state.settings.offsetX;
      offsetYEl.value = state.settings.offsetY;
      dragToggle.checked = state.drag.enabled;

      txtTextEl.value = state.text.value;
      txtFontEl.value = state.text.fontFamily;
      txtSizeEl.value = state.text.sizePx;
      txtColorEl.value = state.text.color;
      txtOpacityEl.value = Math.round(state.text.opacity * 100);
      txtRotEl.value = state.text.rotDeg;
      txtDragToggle.checked = state.text.dragEnabled;
      txtAnchorEl.value = state.text.anchor;
      txtOffXEl.value = state.text.offsetX;
      txtOffYEl.value = state.text.offsetY;
    }

    // Init
    (function init(){
      renderLogoThumb();
      refreshPhotoThumbs();
      syncControls();
      renderTplList();
      setZoom(1, 'fit'); // start in "Fit" mode; preview zoom is visual only
    })();
  </script>
</body>
</html>
